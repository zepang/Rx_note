# HTTP相关

HTTP，全称超文本传输协议，用于传输超媒体文档（例如HTML）的应用层协议

为web浏览器和web服务器之间的通信而设计的

## HTTP常见的状态码

- 200 

请求成功

- 301

永久重定向。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替

- 302

临时重定向。与301类似。但资源只是临时被移动。客户端应继续使用原有URI

- 304

未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源

- 307

临时重定向。与302类似，尽管302有规定临时重定向的时候不能将post请求改为get，但是大部分的客户端都会这样做。307会遵照浏览器标准，不会从post变为get。但是对于处理响应时的行为，各种浏览器有可能出现不同的情况

- 400

客户端请求的语法错误，服务器无法理解

- 401

未被授权，请求要求用户的身份认证

- 403

服务器理解请求客户端的请求，但是拒绝执行此请求

- 404

服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面

- 500

服务器内部错误，无法完成请求

- 502
  
充当网关或代理的服务器，从远端服务器接收到了一个无效的请求

- 503

服务器暂时无法处理用户请求，服务无法使用

## HTTP三次握手和四次挥手

查看本目录下，http三次握手和四次挥手

## 缓存

强缓存：

强制缓存的含义是，当客户端请求后，会先访问缓存数据库看缓存是否存在。如果存在则直接返回；不存在则请求真的服务器，响应后再写入缓存数据库（这里缓存数据库指service work, memory cache, disk cache这些地方）

强制缓存直接减少请求数，是提升最大的缓存策略

可以造成强制缓存的字段是 Cache-control 和 Expires

- Expires

Expires是HTTP/1.0的字段，表示缓存时间，是一个绝对的时间

```
Expires: Thu, 10 Nov 2017 08:45:11 GMT
```

在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求

但是这个字段有以下两个缺点：

1. 由于是绝对时间，用户可以修改客户端本地时间，导致浏览器的缓存失效，重新请求该资源。即使不考虑自行修改时间，时差因素也会导致缓存失效。
2. 值写法过于复杂。表示时间的字符串空格或者拼写错误都会导致失效。

- Cache-control

在HTTP/1.1中，增加了一个字段Cache-control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求。

Cache-control 的优先级高于 Expires，为了兼容 HTTP/1.0 和 HTTP/1.1，实际项目中两个字段都可能设置。

该值为相对时间：

```
Cache-control: max-age=2592000
```

下边是列举一些常见的Cache-control的有效字段：

- `max-age=<seconds>` 设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间。
- `must-revalidate` 一旦资源过期（比如已经超过max-age），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。
- `no-cache` 在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证。虽然中文意思是“不要缓存”，实际上是需要缓存，只不过需要服务器验证
- `no-store` 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比
- `public` 所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)
- `private` 所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值

协商缓存：

也叫对比缓存。当强制缓存失效(超过规定时间)时，就需要使用对比缓存，由服务器决定缓存内容是否失效。

**对比缓存在请求数上和没有缓存是一致的**，但如果是 304 的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此 **在响应体体积上的节省是它的优化点**。

对比缓存是可以和强制缓存一起使用的，作为在强制缓存失效后的一种后备方案。

与对比缓存有关的两组字段（不是两个）:

- Last-Modified 和 If-Modify-Since

  1. 服务器通过 Last-Modified 字段告知客户端，资源最后一次被修改的时间，例如
Last-Modified: Mon, 10 Nov 2018 09:10:11 GMT
  2. 浏览器会将这个值和内容一起记录到缓存数据库中
  3. 下一次请求相同资源时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。因此，请求头中会将上次的`Last-Modified`的值写入到`If-Modified-Since`字段
  4. 服务器会将`Last-Modified`和`If-Modified-Since`的值进行对比，如果没有过期，相应304；反之，则表示修改了，响应状态码200，并返回数据。

  但是他还是有一定缺陷的：

  - 如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。
  - 如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。

- Etag 和 If-None-Match
  
  为了解决上述提到的问题，出现的一组新的字段。

  Etag是文件存储的特殊标识（一般是hash生成），服务器存储着文件的Etag字段（If-None-Match）。之后的流程和 Last-Modified 一致，只是 Last-Modified 字段和它所表示的更新时间改变成了 Etag 字段和它所表示的文件 hash，把 If-Modified-Since 变成了 If-None-Match。服务器同样进行比较，命中返回 304, 不命中返回新资源和 200。

  Etag 的优先级高于 Last-Modified。

缓存小结：

当浏览器请求资源时：

1. 调用Service Worker的fetch事件响应
2. 查看memory cache
3. 查看disk cache
   1. 如果有强制缓存且未失效，则使用强制缓存，不请求服务器。这时的状态码全部是 200
   2. 如果有强制缓存但已失效，使用对比缓存，比较后确定 304 还是 200
4. 发起网络请求，等待响应
5. 如果HTTP头信息设置可以缓存，则将内容缓存到disk cache
6. 无视HTTP头部信息，直接缓存响应内容的引用到memory cache
7. 如果service work匹配到资源并且调用了cache.put()，会把响应内容缓存到Service Worker 的 Cache Storage

具体的内容参考本目录下 一文读懂前端缓存 - 知乎

## HTTPS

## HTTP2

相对于HTTP/1.1的优势：

1. 二进制分帧层
2. 多路复用
3. 服务端推送（server push）优化
4. 头部压缩
5. 请求优先级设置

开启http2之后可以放弃的一些优化：

1. 合并文件
2. 雪碧图
3. 域名分片（担心浏览器请求同一域名的最大数限制）
