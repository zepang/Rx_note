# webpack是什么？

webpack是一个现在JavaScript应用程序的静态模块打包器。当webpack处理应用程序的时候，它会递归的构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有的模块打包成一个或者多个bundle。

# webpack核心概念

- entry：
入口起点，告知webpack使用哪个模块作为构建其内部依赖图的开始。
- output：
告知webpack将它创建的bundle输出到哪个目录。
- loader：
模块转换器，loader让webpack能够去处理那些非JavaScript的文件（webpack自身只理解JavaScript），将所有的类型文件转换为webpack能够处理的有效模块。
- plugin：
loader可以转换各类型的文件，插件则可以执行更广泛的任务，比如打包优化，文件压缩，定义环境变量等等。

# 初始化webpack的项目

从webpack4.0版本起，除了要安装`webpack`还需要`webpack-cli`

```
npm install -D webpack webpack-cli
```

并且，从4.0开始，webpack开箱即用，不引入配置文件的情况就可以使用。关于更多的默认配置可以查看`node_modules/webpack/lib/WebpackOptionsDefaulter.js`

新建`src/index.js`:

```js
class Animal {
  constructor(name) {
      this.name = name;
  }
  getName() {
      return this.name;
  }
}

const dog = new Animal('dog')
```
为了能够看到webpack打包后的代码，我们使用`npx webpack --mode development`进行打包，查看`dist/main.js`:

```js
eval("class Animal {\r\n  constructor(name) {\r\n      this.name = name;\r\n  }\r\n  getName() {\r\n      return this.name;\r\n  }\r\n}\r\n\r\nconst dog = new Animal('dog')\r\n\n\n//# sourceURL=webpack:///./src/index.js?");
```

发现没有被转译成兼容低版本浏览的代码，显然不是我们想要的。

# 转译代码

为了将新的语法转译成兼容低版本浏览器的语法，需要用到`babel-loader`

```js
npm install babel-loader -D
```

babel-loader本身依赖的是babel，所以还需要配置babel

```
npm install @babel/core @babel/preset-env @babel/plugin-transform-runtime -D

npm install @babel/runtime @babel/runtime-corejs3
```

新建webpack.config.js:

```js
module.exports = {
  mode: "development",
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        use: ['babel-loader'],
        exclude: /node_modules/
      }
    ]
  }
}
```

关于babel的配置方式，你可以选择使用新建.babelrc文件进行配置，也可以在webpack中配置babel：

```json
{
  "presets": ["@babel/preset-env"],
  "plugins": [
    [
      "@babel/plugin-transform-runtime",
      {
        "corejs": 3
      }
    ]
  ]
}
```

```js
// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ["@babel/preset-env"],
            plugins: [
              [
                "@babel/plugin-transform-runtime",
                {
                  "corejs": 3
                }
              ]
            ]
          }
        },
        exclude: /node_modules/
      }
    ]
  }
}
```

现在，我们直接使用 npx webpack 进行编译即可。

# 在HTML自动引入打包之后的资源

我们知道，为了更新缓存文件，webpack打包生成的文件都是带hash命名，那么如何每次打包之后都能自动的在HTML引入更新之后的资源呢？

我们需要`webpack-html-plugin`插件

```
npm install webpack-html-plugin -D
```

添加对应的配置：

```js
const webpack = require('webpack')
const HtmlPlugin = require('html-webpack-plugin')

/**
 * 增加 type 注释，vscode将会有提示，帮助写配置
 * @type {webpack.Configuration}
 */
const config = {
  mode: 'development',
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ["@babel/preset-env"],
            plugins: [
              [
                "@babel/plugin-transform-runtime",
                {
                  "corejs": 3
                }
              ]
            ]
          }
        },
        exclude: /node_modules/
      }
    ]
  },
  plugins: [
    new HtmlPlugin({
      template: './public/template.html',
      filename: 'index.html', //打包后的文件名
      minify: {
          removeAttributeQuotes: false, //是否删除属性的双引号
          collapseWhitespace: false, //是否折叠空白
      },
      // hash: true //是否加上hash，默认是 false
    })
  ]
}

module.exports = config
```

# 开发环境实时预览

安装webpack-dev-server
```
npm install webpack-dev-server -D
```
修改package.json命令:

```js
{
  "scripts": {
    "dev": "cross-env NODE_ENV=development webpack-dev-server",
    // ...
  }
}
```

直接运行命令即可，默认有配置，也可以在webpack中自定义一些配置：

```js
{
  // ...
  devServer: {
    open: false, // 用默认的浏览器打开 html
    port: '3000', //默认是8080
    quiet: false, //默认不启用
    inline: true, //默认开启 inline 模式，如果设置为false,开启 iframe 模式
    stats: "errors-only", //终端仅打印 error
    overlay: false, //默认不启用
    clientLogLevel: "silent", //日志等级
    compress: true //是否启用 gzip 压缩
  }
}
```

# 处理样式文件

webpack不能直接处理css文件，需要使用loader。如果是 .css，我们需要的 loader 通常有： style-loader、css-loader，考虑到兼容性问题，还需要 postcss-loader，而如果是 less 或者是 sass 的话，还需要 less-loader 和 sass-loader，这里配置一下 less 和 css 文件(sass 的话，使用 sass-loader即可):
```
npm install style-loader less-loader css-loader postcss-loader autoprefixer less -D
```

添加配置：

```js
{
  // ...
  module: {
    rules: [
      // 样式文件
      {
        test: /\.(le|c)ss$/,
        use: [
          'style-loader',
          'css-loader',
          {
            loader: 'postcss-loader',
            options: {
              plugins: function () {
                return [
                  require('autoprefixer')({
                    "overrideBrowserslist": [
                      ">0.25%",
                      "not dead"
                    ]
                  })
                ]
              }
            }
          },
          'less-loader'
        ]
      }
    ]
  }
}
```

- style-loader 动态创建 style 标签，将 css 插入到 head 中.
- css-loader 负责处理 @import 等语句。
- postcss-loader 和 autoprefixer，自动生成浏览器兼容性前缀 —— 2020了，应该没人去自己徒手去写浏览器前缀了吧
- less-loader 负责处理编译 .less 文件,将其转为 css

这里，我们之间在 webpack.config.js 写了 autoprefixer 需要兼容的浏览器，仅是为了方便展示。推荐大家在根目录下创建 .browserslistrc，将对应的规则写在此文件中，除了 autoprefixer 使用外，@babel/preset-env、stylelint、eslint-plugin-conmpat 等都可以共用。

注意：

loader 的执行顺序是从右向左执行的，也就是后面的 loader 先执行，上面 loader 的执行顺序为: less-loader ---> postcss-loader ---> css-loader ---> style-loader

当然，loader 其实还有一个参数，可以修改优先级，enforce 参数，其值可以为: pre(优先执行) 或 post (滞后执行)

# 图片字体文件处理

我们可以使用 url-loader 或者 file-loader 来处理本地的资源文件。url-loader 和 file-loader 的功能类似，但是 url-loader 可以指定在文件大小小于指定的限制时，返回 DataURL，因此，个人会优先选择使用 url-loader。

```
npm install url-loader -D
```

安装 url-loader 的时候，控制台会提示你，还需要安装下 file-loader，听人家的话安装下就行(新版 npm 不会自动安装 peerDependencies)

```
npm install file-loader -D
```

添加配置：

```js
{
  // ...
  module: {
    rules: {
      // ...
      {
        test: /\.(png|jpg|jpeg|gif|webp|svg|eot|ttf|woff|woff2)$/,
        loader: 'url-loader',
        options: {
          name: '[name]_[hash:6].[ext]',
          limit: 1024,
          esModule: false 
        }
      }
    }
  }
}
```

# 入口配置

```js
//webpack.config.js
module.exports = {
  entry: './src/index.js' //webpack的默认配置
}
```

entry 的值可以是一个字符串，一个数组或是一个对象。

字符串的情况无需多说，就是以对应的文件为入口。

为数组时，表示有“多个主入口”，想要多个依赖文件一起注入时，会这样配置。例如:

```js
entry: [
  './src/polyfills.js',
  './src/index.js'
]
```

polyfills.js 文件中可能只是简单的引入了一些 polyfill，例如 babel-polyfill，whatwg-fetch 等，需要在最前面被引入（我在 webpack2 时这样配置过）。

那什么时候是对象呢？不要捉急，后面将多页配置的时候，会说到。

# 出口配置

```js
const path = require('path');
module.exports = {
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'), //必须是绝对路径
    filename: 'bundle.[hash:8].js',
    publicPath: '/' //通常是CDN地址
  }
}
```

# 每次打包前清空dist目录

```
npm install clean-webpack-plugin -D
```

添加配置：

```js
const { CleanWebpackPlugin } = require('clean-webpack-plugin')
{
  // ...
  plugins: [
    new CleanWebpackPlugin({
      cleanOnceBeforeBuildPatterns:['**/*', '!dll', '!dll/**'] //不删除dll目录下的文件
    })
  ]
}
```

# 复制静态文件

```js
npm install copy-webpack-plugin -D
```

添加配置：

```js
{
  plugins: [
    new CopyWebpackPlugin([
      {
        from: 'public/js/*.js',
        to: path.resolve(__dirname, 'dist', 'js'),
        flatten: true,
      },
      //还可以继续配置其它要拷贝的文件
    ], {
      ignore: ['other.js']
    })
  ]
}
```

# ProvidePlugin

ProvidePlugin 是 webpack 的内置插，将模块变成全局变量，不需要通过import或者require来引入。

React 大家都知道的，使用的时候，要在每个文件中引入 React，不然立刻抛错给你看。还有就是 jquery, lodash 这样的库，可能在多个文件中使用，但是懒得每次都引入，好嘛，一起来偷个懒，修改下 webpack 的配置:

```js
const webpack = require('webpack');
module.exports = {
  //...
  plugins: [
    new webpack.ProvidePlugin({
      React: 'react',
      Component: ['react', 'Component'],
      Vue: ['vue/dist/vue.esm.js', 'default'],
      $: 'jquery',
      _map: ['lodash', 'map']
    })
  ]
}
```
这样配置之后，你就可以在项目中随心所欲的使用 $、_map了，并且写 React 组件时，也不需要 import React 和 Component 了，如果你想的话，你还可以把 React 的 Hooks 都配置在这里。
另外呢，Vue 的配置后面多了一个 default，这是因为 vue.esm.js 中使用的是 export default 导出的，对于这种，必须要指定 default。React 使用的是 module.exports 导出的，因此不要写 default。
另外，就是如果你项目启动了 eslint 的话，记得修改下 eslint 的配置文件，增加以下配置：

```json
{
  "globals": {
    "React": true,
    "Vue": true,
    //....
  }
}
```

# 抽离样式

```
npm install mini-css-extract-plugin -D
```

mini-css-extract-plugin 和 extract-text-webpack-plugin 相比:

1. 异步加载
2. 不会重复编译(性能更好)
3. 更容易使用
4. 只适用CSS

添加配置：

```js
{
  // ...
  plugins: [
    new MiniCssExtractPlugin({
      filename: 'css/[name].css' 
    })
  ],
  module: {
    rules: [
      // 样式文件
      {
        test: /\.(le|c)ss$/,
        use: [
          MiniCssExtractPlugin.loader, // 替换之前的style-loader
          'css-loader',
          {
            loader: 'postcss-loader',
            options: {
              plugins: function () {
                return [
                  require('autoprefixer')({
                    "overrideBrowserslist": [
                      ">0.25%",
                      "not dead"
                    ]
                  })
                ]
              }
            }
          },
          'less-loader'
        ]
      }
    ]
  }
}
```

将抽离出来的css文件进行压缩:

```
npm install optimize-css-assets-webpack-plugin -D
```

添加配置：
```js
const OptimizeCssPlugin = require('optimize-css-assets-webpack-plugin')
{
  // ...
  plugins: [
    new OptimizeCssPlugin()
  ]
}
```

# 按需加载

import() 语法，需要 @babel/plugin-syntax-dynamic-import 的插件支持，但是因为当前 @babel/preset-env 预设中已经包含了 @babel/plugin-syntax-dynamic-import，因此我们不需要再单独安装和配置。


webpack 遇到 import(****) 这样的语法的时候，会这样处理：

- 以**** 为入口新生成一个 Chunk
- 当代码执行到 import 所在的语句时，才会加载该 Chunk 所对应的文件

# 热更新

```js
const webpack = require('webpack')

module.exports = {
  //....
  devServer: {
    hot: true
  },
  plugins: [
    new webpack.HotModuleReplacementPlugin() //热更新插件
  ]
}
```
