# 冒泡排序

比较相邻元素，判断是否符合要求，如果不符合就交换位置来达到排序的目的。

```js
function bubbleSort (arr) {
  let count = 0
  for (let i = 0; i < arr.length -1; i++) {
    for (let j = 0; j < arr.length - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
        console.log('交换', arr)
      }
      count = count + 1
    }
  }
  console.log('循环次数：', count)
  return arr
}

// 交换 (7) [5, 1, 6, 7, 2, 4, 3]
// 交换 (7) [5, 1, 6, 2, 7, 4, 3]
// 交换 (7) [5, 1, 6, 2, 4, 7, 3]
// 交换 (7) [5, 1, 6, 2, 4, 3, 7]
// 交换 (7) [1, 5, 6, 2, 4, 3, 7]
// 交换 (7) [1, 5, 2, 6, 4, 3, 7]
// 交换 (7) [1, 5, 2, 4, 6, 3, 7]
// 交换 (7) [1, 5, 2, 4, 3, 6, 7]
// 交换 (7) [1, 2, 5, 4, 3, 6, 7]
// 交换 (7) [1, 2, 4, 5, 3, 6, 7]
// 交换 (7) [1, 2, 4, 3, 5, 6, 7]
// 交换 (7) [1, 2, 3, 4, 5, 6, 7]
// 循环次数： 36
```

优化1：

对每一对相邻的元素做相同的操作，从开始第一队到最后一对，一次遍历完成后，最后一个元素是最大（或者最小）数。

第二次遍历，重复以上的操作因为最后一个元素已经确定为最大或者最小，所以最后一对不需要进行比较，内层减少一次计算。

第三次，内层减少两次计算。

...

同理，第n次内层减少n-1次计算。

```js
function bubbleSort (arr) {
  let count = 0
  for (let i = 0; i < arr.length -1; i++) {
    for (let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
        console.log('交换', arr)
      }
      count = count + 1
    }
  }
  console.log('循环次数：', count)
  return arr
}
// 交换 (7) [5, 1, 6, 7, 2, 4, 3]
// 交换 (7) [5, 1, 6, 2, 7, 4, 3]
// 交换 (7) [5, 1, 6, 2, 4, 7, 3]
// 交换 (7) [5, 1, 6, 2, 4, 3, 7]
// 交换 (7) [1, 5, 6, 2, 4, 3, 7]
// 交换 (7) [1, 5, 2, 6, 4, 3, 7]
// 交换 (7) [1, 5, 2, 4, 6, 3, 7]
// 交换 (7) [1, 5, 2, 4, 3, 6, 7]
// 交换 (7) [1, 2, 5, 4, 3, 6, 7]
// 交换 (7) [1, 2, 4, 5, 3, 6, 7]
// 交换 (7) [1, 2, 4, 3, 5, 6, 7]
// 交换 (7) [1, 2, 3, 4, 5, 6, 7]
// 循环次数： 21
```

优化2：

我们修改一下输出的内容：

```js
function bubbleSort (arr) {
  let count = 0
  for (let i = 0; i < arr.length -1; i++) {
    console.log(`第${i + 1}次遍历`)
    for (let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
        console.log('交换', arr)
      }
      count = count + 1
    }
  }
  console.log('循环次数：', count)
  return arr
}

// 第1次遍历
// 交换 (7) [5, 1, 6, 7, 2, 4, 3]
// 交换 (7) [5, 1, 6, 2, 7, 4, 3]
// 交换 (7) [5, 1, 6, 2, 4, 7, 3]
// 交换 (7) [5, 1, 6, 2, 4, 3, 7]
// 第2次遍历
// 交换 (7) [1, 5, 6, 2, 4, 3, 7]
// 交换 (7) [1, 5, 2, 6, 4, 3, 7]
// 交换 (7) [1, 5, 2, 4, 6, 3, 7]
// 交换 (7) [1, 5, 2, 4, 3, 6, 7]
// 第3次遍历
// 交换 (7) [1, 2, 5, 4, 3, 6, 7]
// 交换 (7) [1, 2, 4, 5, 3, 6, 7]
// 交换 (7) [1, 2, 4, 3, 5, 6, 7]
// 第4次遍历
// 交换 (7) [1, 2, 3, 4, 5, 6, 7]
// 第5次遍历
// 第6次遍历
// 循环次数： 21
```

可以发现第四次之后第5次和第6次就没有发生过交换，已经排序完毕，但是还在遍历。

所以，我们可以设立一个标记，用来表示当前 `i + 1` 次循环内没有发生过交互，排序完毕，不需要进行后续的遍历。

```js
function bubbleSort (arr) {
  let count = 0
  for (let i = 0; i < arr.length -1; i++) {
    let stopFlag = true
    console.log(`第${i + 1}次遍历`)
    for (let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
        console.log('交换', arr)
        stopFlag = false
      }
      count = count + 1
    }
    if (stopFlag) break
  }
  console.log('循环次数：', count)
  return arr
}

// 第1次遍历
// 交换 (7) [5, 1, 6, 7, 2, 4, 3]
// 交换 (7) [5, 1, 6, 2, 7, 4, 3]
// 交换 (7) [5, 1, 6, 2, 4, 7, 3]
// 交换 (7) [5, 1, 6, 2, 4, 3, 7]
// 第2次遍历
// 交换 (7) [1, 5, 6, 2, 4, 3, 7]
// 交换 (7) [1, 5, 2, 6, 4, 3, 7]
// 交换 (7) [1, 5, 2, 4, 6, 3, 7]
// 交换 (7) [1, 5, 2, 4, 3, 6, 7]
// 第3次遍历
// 交换 (7) [1, 2, 5, 4, 3, 6, 7]
// 交换 (7) [1, 2, 4, 5, 3, 6, 7]
// 交换 (7) [1, 2, 4, 3, 5, 6, 7]
// 第4次遍历
// 交换 (7) [1, 2, 3, 4, 5, 6, 7]
// 第5次遍历
// 循环次数： 20
```

优化3：

我们再次修改一下输出信息：

```js
function bubbleSort (arr) {
  let count = 0
  let unchange = 0
  for (let i = 0; i < arr.length -1; i++) {
    let stopFlag = true
    console.log(`第${i + 1}次遍历`)
    for (let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
        console.log('交换', arr)
        stopFlag = false
      } else {
        unchange = unchange + 1
      }
      count = count + 1
    }
    if (stopFlag) break
  }
  console.log('未交换次数：', unchange)
  console.log('循环次数：', count)
  return arr
}

// 第1次遍历
// 交换 (7) [5, 1, 6, 7, 2, 4, 3]
// 交换 (7) [5, 1, 6, 2, 7, 4, 3]
// 交换 (7) [5, 1, 6, 2, 4, 7, 3]
// 交换 (7) [5, 1, 6, 2, 4, 3, 7]
// 第2次遍历
// 交换 (7) [1, 5, 6, 2, 4, 3, 7]
// 交换 (7) [1, 5, 2, 6, 4, 3, 7]
// 交换 (7) [1, 5, 2, 4, 6, 3, 7]
// 交换 (7) [1, 5, 2, 4, 3, 6, 7]
// 第3次遍历
// 交换 (7) [1, 2, 5, 4, 3, 6, 7]
// 交换 (7) [1, 2, 4, 5, 3, 6, 7]
// 交换 (7) [1, 2, 4, 3, 5, 6, 7]
// 第4次遍历
// 交换 (7) [1, 2, 3, 4, 5, 6, 7]
// 第5次遍历
// 未交换次数： 8
// 循环次数： 20
```

我们发现没有交换的循环次数有8次，也就是20次的循环有8次无效。

如何减少这部分的无效循环？我们可以添加一个lastPosition记录上个遍历里边最后交换的元素的位置。因为最后交换这个元素后面的元素是可以保证比之前的都大的。

代码和结果如下：

```js
function bubbleSort (arr) {
  let count = 0
  let unchange = 0
  let lastPosition = arr.length - 1
  for (let i = 0; i < arr.length -1; i++) {
    let stopFlag = true
    // 每次开始重新计算内层循环次数
    let len = lastPosition
    console.log(`第${i + 1}次遍历`)
    for (let j = 0; j < len; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
        console.log('交换', arr)
        lastPosition = j
        stopFlag = false
      } else {
        unchange = unchange + 1
      }
      count = count + 1
    }
    if (stopFlag) break
  }
  console.log('未交换次数：', unchange)
  console.log('循环次数：', count)
  return arr
}

// 第1次遍历
// 交换 (7) [5, 1, 6, 7, 2, 4, 3]
// 交换 (7) [5, 1, 6, 2, 7, 4, 3]
// 交换 (7) [5, 1, 6, 2, 4, 7, 3]
// 交换 (7) [5, 1, 6, 2, 4, 3, 7]
// 第2次遍历
// 交换 (7) [1, 5, 6, 2, 4, 3, 7]
// 交换 (7) [1, 5, 2, 6, 4, 3, 7]
// 交换 (7) [1, 5, 2, 4, 6, 3, 7]
// 交换 (7) [1, 5, 2, 4, 3, 6, 7]
// 第3次遍历
// 交换 (7) [1, 2, 5, 4, 3, 6, 7]
// 交换 (7) [1, 2, 4, 5, 3, 6, 7]
// 交换 (7) [1, 2, 4, 3, 5, 6, 7]
// 第4次遍历
// 交换 (7) [1, 2, 3, 4, 5, 6, 7]
// 第5次遍历
// 未交换次数： 8
// 循环次数： 20
```

结果和未优化前一样，其实是案例有问题，有些优化指针对特俗情况。尝试换一个数组：`[6,3,4,1,2,7,8,9]`

未优化前：

```
第1次遍历
交换 (8) [3, 6, 4, 1, 2, 7, 8, 9]
交换 (8) [3, 4, 6, 1, 2, 7, 8, 9]
交换 (8) [3, 4, 1, 6, 2, 7, 8, 9]
交换 (8) [3, 4, 1, 2, 6, 7, 8, 9]
第2次遍历
交换 (8) [3, 1, 4, 2, 6, 7, 8, 9]
交换 (8) [3, 1, 2, 4, 6, 7, 8, 9]
第3次遍历
交换 (8) [1, 3, 2, 4, 6, 7, 8, 9]
交换 (8) [1, 2, 3, 4, 6, 7, 8, 9]
第4次遍历
未交换次数： 14
循环次数： 22
```

优化后：

```js
第1次遍历
交换 (8) [3, 6, 4, 1, 2, 7, 8, 9]
交换 (8) [3, 4, 6, 1, 2, 7, 8, 9]
交换 (8) [3, 4, 1, 6, 2, 7, 8, 9]
交换 (8) [3, 4, 1, 2, 6, 7, 8, 9]
第2次遍历
交换 (8) [3, 1, 4, 2, 6, 7, 8, 9]
交换 (8) [3, 1, 2, 4, 6, 7, 8, 9]
第3次遍历
交换 (8) [1, 3, 2, 4, 6, 7, 8, 9]
交换 (8) [1, 2, 3, 4, 6, 7, 8, 9]
第4次遍历
未交换次数： 5
循环次数： 13
```