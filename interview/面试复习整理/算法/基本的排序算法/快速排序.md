# 快速排序

快速排序的核心是分治法。

1. 从数组元素中挑出一个基准值（pivotVal）。
2. 重新排序数组，将所有小于改基准值的元素放在基准值的前面，将所有大于改基准值的元素放到基准值的后面。以基准值为分界值，将数列划分为两部分。
3. 递归的分别排序小于基准值的元素和大于基准值的元素。

```js
function partition (arr, low, hight) {
  // 基准值
  let pivotVal = arr[low]
  while(low < hight) {
    while(low < hight && pivotVal <= arr[hight]) {
      hight--
    }
    
    [arr[low], arr[hight]] = [arr[hight], arr[low]]
    console.log(`发生交换`, arr)

    while(low < hight && arr[low] <= pivotVal) {
      low++
    }
    
    [arr[low], arr[hight]] = [arr[hight], arr[low]]
    console.log(`发生交换`, arr)
    debugger
  }
  return low
}

function quickSort (arr, low, hight) {
  let pivot
  low = low
  hight = hight

  if (low < hight) {
    // 1. 获取中间值的索引
    pivot = partition(arr, low, hight)
    // 2. 分别排序小于基准值的元素和大于基准值的元素
    quickSort(arr, low, pivot - 1)
    quickSort(arr, pivot + 1, arr.length - 1)
  }
}

```

测试一下：

```js
var arr = [5, 1, 9, 3, 7, 4, 8, 6, 2]
quickSort()
console.log(arr)

// 发生交换 (9) [2, 1, 9, 3, 7, 4, 8, 6, 5]
// 发生交换 (9) [2, 1, 5, 3, 7, 4, 8, 6, 9]
// 发生交换 (9) [2, 1, 4, 3, 7, 5, 8, 6, 9]
// 发生交换 (9) [2, 1, 4, 3, 5, 7, 8, 6, 9]
// 发生交换 (9) [2, 1, 4, 3, 5, 7, 8, 6, 9]
// 发生交换 (9) [2, 1, 4, 3, 5, 7, 8, 6, 9]
// 发生交换 (9) [1, 2, 4, 3, 5, 7, 8, 6, 9]
// 发生交换 (9) [1, 2, 4, 3, 5, 7, 8, 6, 9]
// 发生交换 (9) [1, 2, 4, 3, 5, 6, 8, 7, 9]
// 发生交换 (9) [1, 2, 4, 3, 5, 6, 7, 8, 9]
// 发生交换 (9) [1, 2, 4, 3, 5, 6, 7, 8, 9]
// 发生交换 (9) [1, 2, 4, 3, 5, 6, 7, 8, 9]
```

优化1：

我们看一下上述的一个结果，5作为基准值，在第四次交换才被移到正确的位置，所以前三次的交换对于基准值来说都是无效的。对于第二次和第三的基准值也是一样。

那么如何减少这部分的交换？我们知道`partition`返回的low即是基准值的位置，也就是说只要最后确定了基准值位置再交换就可以了。

```js
function partition (arr, low, hight) {
  let startIndex = low
  // 基准值
  let pivotVal = arr[low]
  while(low < hight) {
    while(low < hight && pivotVal <= arr[hight]) {
      hight--
    }

    while(low < hight && arr[low] <= pivotVal) {
      low++
    }
    
    [arr[low], arr[hight]] = [arr[hight], arr[low]]
    console.log(`发生交换`, arr, low, hight)
  }
  [arr[startIndex], arr[low]] = [arr[low], arr[startIndex]]
  console.log(`最后交换`, arr, startIndex, low)
  return low
}

function quickSort (arr, low, hight) {
  let pivot
  low = low
  hight = hight

  if (low < hight) {
    // 1. 获取中间值的索引
    pivot = partition(arr, low, hight)
    // 2. 分别排序小于基准值的元素和大于基准值的元素
    quickSort(arr, low, pivot - 1)
    quickSort(arr, pivot + 1, arr.length - 1)
  }
}

var arr = [5, 1, 9, 3, 7, 4, 8, 6, 2]
quickSort(arr)
console.log(arr)

// 发生交换 (9) [5, 1, 2, 3, 7, 4, 8, 6, 9] 2 8
// 发生交换 (9) [5, 1, 2, 3, 4, 7, 8, 6, 9] 4 5
// 发生交换 (9) [5, 1, 2, 3, 4, 7, 8, 6, 9] 4 4
// 最后交换 (9) [4, 1, 2, 3, 5, 7, 8, 6, 9] 0 4
// 发生交换 (9) [4, 1, 2, 3, 5, 7, 8, 6, 9] 3 3
// 最后交换 (9) [3, 1, 2, 4, 5, 7, 8, 6, 9] 0 3
// 发生交换 (9) [3, 1, 2, 4, 5, 7, 6, 8, 9] 6 7
// 发生交换 (9) [3, 1, 2, 4, 5, 7, 6, 8, 9] 6 6
// 最后交换 (9) [3, 1, 2, 4, 5, 6, 7, 8, 9] 5 6
```

这种优化目前还有问题
