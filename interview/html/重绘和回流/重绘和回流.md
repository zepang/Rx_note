# 回流和重绘

# 浏览器的渲染过程

![](./1.png)

从上图中我们可以看到,浏览器的一个渲染过程:

1. 解析HTML,生成DOM树,解析CSS,生成DOM树
2. 将DOM树和CSS树结合,生成渲染树
3. layout(回流):根据生成的渲染树,进行回流,得到节点的位置 大小等几何信息
4. painting(重绘): 根据渲染树以及回流得到的几何信息，得到节点的绝对像素
5. display: 将像素发送给GPU,展示在页面

有了上边第二步得到的渲染树,就可以进入布局阶段,为弄清每个对象在网页上的确切大小和位置，浏览器从渲染树的根节点开始进行遍历,得到这些信息,这个阶段就叫自动重排

布局完成之后,浏览器会立即发出“Paint Setup”和“Paint”事件，也就是绘制, 将渲染树转换成屏幕上的像素

所以,我们可以对回流和重绘做出以下定义:

* 回流: 引发自动重排的过程叫做回流
* 重绘: 引发绘制的过程叫重绘

# 何时会引发回流与重绘

我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：

* 添加或删除可见的DOM元素
* 元素的位置发生变化
* 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
* 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
* 页面一开始渲染的时候（这肯定避免不了）
* 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）
* 根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。

**注意：回流一定会触发重绘，而重绘不一定会回流**

不需要计算大小位置等几何信息的属性值改变,只会引起重绘,比如颜色

# 如何减少回流和重绘

## 浏览器的优化机制

现代浏览器都比较聪明,由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！**当你获取布局信息的操作的时候，会强制队列刷新**，比如当你访问以下属性或者使用以下方法：

* offsetTop、offsetLeft、offsetWidth、offsetHeight
* scrollTop、scrollLeft、scrollWidth、scrollHeight
* clientTop、clientLeft、clientWidth、clientHeight
* getComputedStyle()
* getBoundingClientRect
* 具体可以访问这个网站：[https://gist.github.com/paulirish/5d52fb081b3570c81e3a](https://gist.github.com/paulirish/5d52fb081b3570c81e3a)

以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，**最好避免使用上面列出的属性，他们都会刷新渲染队列。**如果要使用它们，最好将值缓存起来。

## 通过代码优化

```js
const el = document.getElementById('test');
el.style.padding = '5px';
el.style.borderLeft = '1px';
el.style.borderRight = '2px';
```

类似这种分三次修改属性引起回流的操作,大部分的浏览器都对其进行了优化,只会进行一次回流,但是,旧版浏览器可能没有做相关的优化,因此需要我们在代码上做一定的优化

* 使用cssText

```js
const el = document.getElementById('test');
el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;';
```

* 修改css类名

```js
const el = document.getElementById('test');
el.className += ' active';
```

## 批量修改dom

当我们需要对dom进行一系列的操作的时候,可以通过以下步骤减少回流重绘次数:

* 使元素脱离文档流
* 对其进行多次修改
* 将元素带回到文档中

该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流重绘，因为它已经不在渲染树了

有三种方式可以让DOM脱离文档流：

* 隐藏元素，应用修改，重新显示
* 使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。
* 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。

```js
function appendDataToElement(appendToElement, data) {
    let li;
    for (let i = 0; i < data.length; i++) {
    	li = document.createElement('li');
        li.textContent = 'text';
        appendToElement.appendChild(li);
    }
}
const ul = document.getElementById('list');
ul.style.display = 'none';
appendDataToElement(ul, data);
ul.style.display = 'block';
```

```js
const ul = document.getElementById('list');
const fragment = document.createDocumentFragment();
appendDataToElement(fragment, data);
ul.appendChild(fragment);
```

```js
const ul = document.getElementById('list');
const clone = ul.cloneNode(true);
appendDataToElement(clone, data);
ul.parentNode.replaceChild(clone, ul);
```

其实思路都是减少操作dom的次数,**但是现代浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑。**

## css3硬件加速（GPU加速）

比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3硬件加速就闪亮登场啦！！

1. 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。

2. 对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

**如何触发硬件加速**

常见的触发硬件加速的css属性：

* transform
* opacity
* filters
* Will-change

所以我们可以通过硬编码的方式开启硬件加速, 比如

```css
.example1 { transform: translateZ(0); } 
.example2 { transform: rotateZ(360deg); }
```

**css3硬件加速的坑**

当然，任何美好的东西都是会有对应的代价的，过犹不及。css3硬件加速还是有坑的:

1. 如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题
2. 在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊