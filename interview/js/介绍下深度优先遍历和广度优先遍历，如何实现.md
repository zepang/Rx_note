## 介绍下深度优先遍历和广度优先遍历，如何实现？

html代码

```html
  <div class="parent">
    <div class="child-1">
      <div class="child-1-1">
        <div class="child-1-1-1"></div>
        <div class="child-1-1-2"></div>
        <div class="child-1-1-3"></div>
      </div>
      <div class="child-1-2">
        <div class="child-1-2-1"></div>
        <div class="child-1-2-2"></div>
      </div>
      <div class="child-1-3"></div>
    </div>
    <div class="child-2">
      <div class="child-2-1"></div>
      <div class="child-2-2"></div>
      <div class="child-2-3"></div>
    </div>
    <div class="child-3">
      <div class="child-3-1"></div>
      <div class="child-3-2">
        <div class="child-3-2-1"></div>
        <div class="child-3-2-2"></div>
        <div class="child-3-2-3"></div>
      </div>
      <div class="child-3-3"></div>
    </div>
  </div>
```

### 深度优先遍历

深度优先遍历DFS与树的先序遍历比较类似。假设初始状态是途中所有定点均为被访问，则从某个定点出发，首先访问该顶点然后依次从它的各个未被访问的邻接点出发，优先遍历搜索便利图，知道途中所有和顶点有路径相通的顶点都被访问到。若，此时尚有其他的定点未被访问到，则另选一个未被访问的顶点作为起始点，重复上述过程，知道图中所有顶带你都被访问到为止。

```js
// 深度遍历的三种方式

// 递归思路
let deepTraversal1 = (node, nodeList = []) => {
  if (node !== null) {
    nodeList.push(node)
    let children = node.children
    for (let i = 0; i < children.length; i++) {
      deepTraversal1(children[i], nodeList)
    }
  }
  return nodeList
}

let deepTraversal2 = (node) => {
  let nodes = []
  if (node !== null) {
    nodes.push(node)
    let children = node.children
    for (let i = 0; i < children.length; i++) {
      nodes = nodes.concat(traversal2(children[i]))
    }
  }
}

// 非递归思路
let deepTraversal3 = (node) => {
  let stack = []
  let nodes = []
  if (node) {
    stack.push(node)
    while (stack.length) {
      let item = stack.pop()
      let children = item.children
      nodes.push(item)
      for (let i = children.length - 1; i >= 0; i--) {
        stack.push(children[i])
      }
    }
  }
  return nodes
}
```
#### generator +Interator接口实现深度遍历
```js
function *DFS(tree){
    yield tree;
    let children=tree.children;
    if(children){
        for(let child of children){
            yield *DFS(child)
        }
    }
}
console.log([...DFS(tree)])
```

## 广度优先遍历

广度优先遍历BFS从图中某顶点触发，在访问了顶点之后依次访问顶点的各个未曾访问的邻接点，然后分别从这些邻接点一次访问他们的邻接点，直到图中所有已被访问的顶点的邻接点都被访问。如果此时图中尚有未被访问的顶点，则需要选择另一个未被访问过的顶带你作为新的起始点，重复上述过程，知道图中所有顶点都被访问为止。

```js
let widthTraversal1 = node => {
  let nodes = []
  let stack = []
  if (node) {
    stack.push(node)
    while(stack.length) {
      let item = stack.shift()
      let children = item.children
      nodes.push(item)
      for (let i = 0; i < children.length; i++) {
        stack.push(children[i])
      }
    }
  }
  return nodes
}
```