# 构造函数

## 什么是构造函数？

构造函数本身就是一个函数，与普通函数没有任何区别，不过为了规范会将其名称首字母大写。构造函数和普通函数的区别在于，用`new`运算符调用生成实列的函数就是构造函数，直接调用的函数就是普通函数。

使用构造函数创建的实例对象会从它的原型上继承一个`constructor`属性，`constructor`返回创建实例时的构造函数的引用。

```js
function Parent () {

}

let instance = new Parent()
instance.constructor === Parent // true
```

同样的，使用普通函数创建的对象也会有`constructor`属性，所有的对象都会从它的原型上继承一个`constructor`属性:

```js
function parent () {
  return {}
}
let instance = parent()
instance.constructor === Object // true
```

## Symbol是构造函数吗？

`Symbol()`会返回一个类型为基本类型`symbol`的值，你可以认为他和其他的内置对象类似，但是`Symbol`不支持 `new Symbol()` 语法，直接调用`Symbol()`就可以生成实例对象，
并且使用`Symbol()`生成的实例也是带有constructor属性，默认为`Symbol`函数。

```js
let symbol = Symbol(123)
symbol.constructor === Symbol // true
```

## constructor值只读吗？

这个得分情况，对于引用类型来说`constructor`属性值是可以修改的，但是对于基本类型来说是只读。

引用类型，比如原型链继承，就需要对`constructor`重新赋值进行修正

```js
function Parent () {}
function Child () {}

Child.prototype = new Parent()

Child.prototype.constructor = Parent
Parent.prototype.constructor === Child.prototype.constructor // true
```

对于基本类型来说，`constructor`是只读的。

```js
function Type () {}
var types = [1, 'abc', true, Symbol(123)]

for(var i = 0; i < types.length; i++) {
  types[i].constructor = Type
  types[i] = [types[i].constructor, types[i] instanceof Type, types[i].toString()]
}

console.log(types.join('\n'))
// function Number() { [native code] }, false, 1
// function String() { [native code] }, false, abc
// function Boolean() { [native code] }, false, true
// function Symbol() { [native code] }, false, Symbol(123)
```
因为创建他们的是原生构造函数（`native constructor`）

## 模拟实现 new 

我们来看一下 `new` 操作符到底干了什么？以下内容来自 mdn

The new operator lets developers create an instance of a user-defined object type or of one of the built-in object types that has a constructor function. The new keyword does the following things（`new`操作符允许开发者创建用户自定义对象类型或者带有构造函数的内置对象类型之一的实例，它干了以下几件事）:

1. Creates a blank, plain JavaScript object;（创建一个空白的普通对象）
2. Links (sets the constructor of) this object to another object;（将当前对象与目标对象关联（设置构造函数）起来// 执行原型链接）
3. Passes the newly created object from Step 1 as the this context;（将步骤1创建的新对象作为当前函数上下文）
4. Returns this if the function doesn't return its own object.（返回当前的函数如果函数没有返回对象）


```js
function Car (color) {
  this.color = color
}

Car.prototype.start = function () {
  console.log('start')
}

var car = new Car('red')

// 访问定义属性
car.color // 'red'
// 访问原型链上函数
car.start() // 'start'
// 访问未定义属性
car.name // undefined
```

#### 模拟一

```js
function create () {
  // 1. 创建一个空白对象
  var obj = new Object()
  var fn = Array.prototype.shift.call(arguments)
  // 2. 链接原型
  obj.__proto__ = fn.prototype
  // 3. 关联上下文
  var result = fn.apply(obj, arguments) // 在第一步已经使用shift抛出了第一个值，剩下的都是需要的参数
  // 4. 如果函数fn有返回对象就用函数原来的返回对象，如果没有返回步骤一创建的 obj
  return result instanceof Object ? result : obj
}
```
测试一：

```js
var car = create(Car, 'red')

// 访问定义属性
car.color // 'red'
// 访问原型链上函数
car.start() // 'start'
// 访问未定义属性
car.name // undefined
```

与案例的返回结果一样。

接下来我们看看如果 Car 返回对象的情况：

```js
function Car (color) {
  this.color = color

  return {
    name: 'red car'
  }
}

Car.prototype.start = function () {
  console.log('start')
}

var car = new Car('red')

// 访问定义属性
car.color // 'undefined'
// 访问原型链上函数
car.start() // 'Uncaught TypeError: car.start is not a function'
// 访问未定义属性
car.name // 'red car
```

测试二：

```js
var car = create(Car, 'red')

// 访问定义属性
car.color // 'undefined'
// 访问原型链上函数
car.start() // 'Uncaught TypeError: car.start is not a function'
// 访问未定义属性
car.name // 'red car
```

结果完全一致

# 原型（prototype）

每个对象都拥有一个**原型对象**(并非代码层面的指对象都有这个属性，就是抽象说明每个对象都是对应有一个原型对象)，对象以原型为模板，从原型继承芳芳和属性，这些属性和方法定在对象构造器函数的`prototype`属性上，而非实例本身。

![](./1.png)



