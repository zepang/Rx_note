## 请分别用深度优先思想和广度优先思想实现一个拷贝函数？

下边是常见的一种写法

```js
const typesMap = new Map([
  ['[object Boolean]', 'boolean'],
  ['[object Number]', 'number'],
  ['[object String]', 'string'],
  ['[object Null]', 'null'],
  ['[object Undefined]', 'undefined'],
  ['[object Symbol]', 'symbol'],
  ['[object Object]', 'object'],
  ['[object Array]', 'array'],
  ['[object Function]', 'function'],
  ['[object Date]', 'date'],
  ['[object RegExp]', 'regExp']
])

function deepClone(target) {
  let memory = new Map()

  function baseClone(target) {
    let type = typesMap.get(
      Reflect.apply(Object.prototype.toString, target, [])
    )
    let result
    switch (type) {
      case 'array':
        result = []
        for (let key in target) {
          result[key] = baseClone(target[key])
        }
        break
      case 'object':
        result = {}
        for (let key in target) {
          if (memory.get(target[key])) {
            result[key] = memory.get(target[key])
          } else {
            memory.set(target[key], target[key])
            result[key] = baseClone(target[key])
          }
        }
        break
      default:
        result = target
    }

    return result
  }

  return baseClone(target)
}
```

实际上只要处理Object，Array的深拷贝，其他的基本类型都是浅拷贝。另外需要注意的是处理循环应用导致爆栈的问题。

上边的做法是使用深度度的思想加上递归的写法来实现的一种拷贝。接下来看看不使用递归的写法。

* 基于深度思想的无递归写法

```js

function deepClone(target) {
  let memory = new Map()
  let type = typesMap.get(
    Reflect.apply(Object.prototype.toString, target, [])
  )
  let result

  function baseClone (target, result) {
    let queue = [target]
    while(queue.length) {
      queue.pop()
      for (let key in target) {
        if (memory.get(target[key])) {
          result[key] = memory.get(target[key])
        } else {
          if (
            ['object', 'array'].indexOf(typesMap.get(
              Reflect.apply(Object.prototype.toString, target, [])
            )) > -1
          ) {
            queue.push(target)
            memory.set(target[key], target[key])
          } else {
            result[key] = target[key]
          }
        }
      }
    }
    return result
  }

  switch (type) {
    case 'array':
      result = baseClone(target, [])
      break
    case 'object':
      result = baseClone(target, {})
      break
    default:
      result = target
  }
  
  return result
}
```

* 基于广度思想的无递归写法


```js

function deepClone(target) {
  let memory = new Map()
  let type = typesMap.get(
    Reflect.apply(Object.prototype.toString, target, [])
  )
  let result

  function baseClone (target, result) {
    let stack = [target]
    while(stack.length) {
      stack.shift()
      for (let key in target) {
        if (memory.get(target[key])) {
          result[key] = memory.get(target[key])
        } else {
          if (
            ['object', 'array'].indexOf(typesMap.get(
              Reflect.apply(Object.prototype.toString, target, [])
            )) > -1
          ) {
            stack.push(target)
            memory.set(target[key], target[key])
          } else {
            result[key] = target[key]
          }
        }
      }
    }
    return result
  }

  switch (type) {
    case 'array':
      result = baseClone(target, [])
      break
    case 'object':
      result = baseClone(target, {})
      break
    default:
      result = target
  }
  
  return result
}
```
基于深度和广度的区别在于遍历的方向。假如有一颗树，根节点下有两子节点A,B，A,B分别有两个孙节点C,D 和 E, F。从跟节点开始遍历，跟节点 -> 子节点 A -> 孙节点 C 和 D -> 子节点B -> 孙节点 E 和 F，这种遍历的思想叫深度思想。 从跟节点开始遍历，跟节点 -> 子节点 A -> 子节点 B -> 孙节点 C 和 D -> 孙节点 E 和 F，这种遍历的思想叫广度度思想。其实从代码中不难发现，无非就是通过队列来栈的思想来控制遍历的方向。
