# 第一部分

## 第一章 作用域是什么？

存储和查找变量的规则。

### 1.1 编译原理：
* JavaScript实际上一门编译语言。任何JavaScript的代码在执行前都要进行编译。大部分的编译发生在代码执行前的几微妙（甚至更短）。
* 编译的三个过程：
  * 分词/词法分析
  * 解析/语法分析
  * 代码生成

### 1.2 作用域的理解
* 对 JavaScript 代码进行处理时需要参与的三个成员 引擎，编译器，作用域以及它们分别的作用。
* 作用域参与编译器和引擎的工作，协助编译器和引擎存储和查找变量

### 1.3 作用域嵌套
* 遍历嵌套作用域链的规则：引擎从当前的执行作用域开始查找变量，如果找不到，
就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都
会停止。

### 1.4 异常
在普通模式下，执行 LHS 查询，如果直到顶层作用域都无法找到所需的变量，会在顶层作用域，隐式的创建一个。执行 RHS 查询，在所有的嵌套作用中，无法找到需要的变量，引擎会抛出 ReferenceError 异常。
在严格模式下（'use strict'），执行 LHS 查询，如果直到顶层作用域都无法找到所需的变量，不会在顶层作用域隐式的创建一个，引擎会抛出 ReferenceError 异常，因为严格模式不允许隐式创建变量。

---

## 第二章 词法作用域
作用域共有两种主要的工作模型，第一种最为普遍，被大多数编程语言所采用的词法作用域。另外一种叫做动态作用域，仍有一些编程语言在使用。JavaScript所采用的模型是词法作用域。
举个例子说明动态作用域和词法作用域的区别：
~~~js
function foo () {
  console.log(a)
}
function bar () {
  var a = 3
  foo()
}
var a = 2
bar() // 2
~~~
上边的代码 js 会输出 2，因为 foo 函数的 RHS 查找变量是通过全局的作用域进行查找的
如果 js 是动态语言，那么结果就会输出 3，动态作用域不关心函数是在何处声明的，只关心在何处调用。
### 2.1 词法阶段
在之前的[1.1编译原理](###1.1编译原理)中提到编译器工作的三个阶段，第一个是词法分析，大部分标准编译器的第一个工作阶段叫做词法化。
**简单的来说，词法作用域就是定义在词法阶段的作用域。换句话来说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，由此，当词法分析器处理代码时，会保持作用域不变**
### 2.2 词法欺骗
刚才所说，词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”（欺骗），词法作用域？

JavaScript 中有两种方式：eval 和 with

#### 2.2.1 eval
eval 函数可以接收一个字符串为参数，并且将其中内容作为好像在书写时就在当前位置的代码来执行。请看下面例子：
~~~js
function foo (str) {
  eval(str)
  console.log(a)
}
var a = 1
foo("var a = 3") // 3
~~~
eval 常用来动态创建代码，但是，在严格模式中，eval(...) 在运行时有其自己的作用域，意味着无法修改所在地作用域。
~~~js
function foo (str) {
  eval(str)
  console.log(a) // ReferenceError: a is not defined
}
foo("var a = 3") 
~~~
setTimeout(...) 和 setInterval(...) 的第一个参数可以是字符串，字符串的代码可以解释成正确的代码执行。这些功能已经过时，不要使用它。

new Function(...) 函数最后一个参数可以接收代码字符串，并且将其转化成动态代码。这种做法比eval(...)略微安全，但是，也要尽量避免使用。

#### with
通常被当作重复引用同一个对象的多个属性的快捷方式，可以不需要重复引用对象本身。
~~~js
var obj = {
  a: 1,
  b: 2,
  c: 3
}
obj.a = 4
obj.b = 5
obj.c = 6

with(obj) {
  a = 4
  b = 5
  c = 6
  d = 7
}

console.log(d) // 7
~~~
with 可以将一个没有或者多个属性的对象处理为一个完全隔离的词法作用域。实际上，是根据你传递给它的对象凭空创造一个新的词法作用域。比如，你传递 obj 给 with，实际上，with 以 obj 作为当前作用域，在 obj 中没有找到 d ，所以，在上层作用域中找，也没有，那么就创建了 d 变量。

---

## 第三章 函数作用域和块作用域
JavaScript是如何形成作用域气泡？

两种方式，一种是函数作用域，另一种是块作用域。

### 函数作用域
每次创建一个函数就可以为其自身创建一个作用域气泡。
### 块作用域
通过 with try/catch let const 等关键字形成的块级作用域。
其中try/catch 中的 catch 分句会创建块作用域，其中声明的变量只能在catch内部有效。

----

## 第四章 提升
先看下面代码：
~~~js
// ---
a = 2;
var a;
consoel.log(a) // 2
// ---
console.log(a) // undefined
var a = 2
~~~
通常我们理解的JavaScript的代码是一行一行从上往下执行，所以我们猜测上边代码会报 ReferenceError 错误。但是，由于 JavaScript 是先编译后执行，在编译阶段会收集所有的声明，虽然，我们看到的 a 声明代码在 赋值代码后面，但是，编译器已经提前在作用域中声明了 a，所以，在执行阶段，对 a 进行 RHS 查询，不会报错。这一个现象叫提升。

JavaScript 中除了上边的变量提升，还存在函数提升，不过只针对 function 关键字声明的函数。

---- 

## 第五章 作用域闭包
### 闭包
闭包的产生？

当函数记住并且访问词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

什么叫闭包？

~~~js
function foo () {
  var a = 2
  function bar () {
    console.log(a)
  }
  bar()
}
f00()
~~~
我们可以这么解释上边的代码，bar 函数在创建时是在 foo 函数内部，所以，bar 函数所适应访问的变量的规则时，当前作用域 -> foo作用域 -> foo外层作用域，bar 函数在执行的时候，根据作用域嵌套规则，首先会在当前作用域寻找 a，不存在就会往上寻找，而 foo 作用域 是可以访问到 a 的。
那么下边代码我们该如何解释？
~~~js
function foo () {
  var a = 2
  function bar () {
    console.log(a)
  }
  return bar
}
var baz = foo()
baz() // 2 闭包产生的效果
~~~
如果我们继续按照上边的思路去解释，那么我们会发现一个问题，由于JavaScript本身存在的垃圾回收机制，在 var baz = foo() 执行完后，foo 函数就应该会回收，所以 foo 中声明的所有上下文环境变量就该销毁，显然baz()执行的时候是无法找到 a 的。那么此处最终结果依然输出 2，可以看出 foo 在执行时生成的上下文环境变量没有被销毁，闭包阻止了垃圾回收。

个人的理解：
- 作用域
  * 同意书上JavaScript使用的是词法作用域，所以决定变量的使用范围是在词法分析阶段。
  * JavaScript作用域从范围来分，分为全局作用域和局部作用域，从不同的生成方式来分，分为函数作用域（由创建函数形成的作用域）和块级作用域（形成块级作用域的关键字声明形成）。
- 闭包

  当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时
  就产生了闭包。
  * 在函数A中返回函数B，函数B对函数A的作用域存在引用，我们就说函数A形成了闭包，函数B就是函数A的闭包。

---

# 第二部分

## 第一章 关于 this

### 对 this 的误解

* this 指向函数自身
~~~js
function foo(num) {
  console.log( "foo: " + num );
// 记录 foo 被调用的次数
  this.count++;
}
foo.count = 0;
var i;
for (i=0; i<10; i++) {
  if (i > 5) {
  foo( i );
  }
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9
// foo 被调用了多少次？
console.log( foo.count ); // 0 -- WTF?
~~~
foo 调用实际上是增加了全局的 count。

**就针对上面的代码，如何回避以上问题：** 
* 第一种
~~~js
function foo(num) {
  console.log( "foo: " + num );
  // 记录 foo 被调用的次数
  data.count++;
}
var data = {
  count: 0
};
var i;
for (i=0; i<10; i++) {
  if (i > 5) {
  foo( i );
  }
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9
// foo 被调用了多少次？
console.log( data.count ); // 4
~~~
创建一个对象来存储 count，回避掉 this 的问题，用词法作用域来解释。
* 第二种
~~~js
function foo(num) {
  console.log( "foo: " + num );
  // 记录 foo 被调用的次数
  foo.count++;
}
var data = {
  count: 0
};
var i;
for (i=0; i<10; i++) {
  if (i > 5) {
  foo( i );
  }
}
~~~
使用具名函数，指定函数名。
* 第三种
~~~js
function foo(num) {
  console.log( "foo: " + num );
  // 记录 foo 被调用的次数
  // 注意，在当前的调用方式下（参见下方代码），this 确实指向 foo
  this.count++;
}
foo.count = 0;
var i;
for (i=0; i<10; i++) {
  if (i > 5) {
  // 使用 call(..) 可以确保 this 指向函数对象 foo 本身
    foo.call( foo, i );
  }
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9
// foo 被调用了多少次？
console.log( foo.count ); // 4
~~~
使用 call apply bind 这一类，强制绑顶 this 的指向。

* this 指向函数作用域
（说实话没看懂作者举的例子和当前的主题有啥干系）

#### 小结 

this 既不指向函数自身也不指向函数的词法作用域，this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。


## 第二章 全面了解 this 
### this的绑定规则
#### 默认绑定

独立函数调用（作为普通的函数调用），在非严格的模式下，this 指向全局对象。在严格模式下，this 是 undefined。
~~~js
function foo () {
  console.log(this.a)
}
var a = 2
foo()
~~~
书上的说法是 foo 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定。

#### 隐式绑定
通常就是我们所说的把函数当做对象的属性调用，因此隐式绑定规则会把 this 绑定到这个上下文对象。还需要注意的一点是：对象属性引用链中只有最顶层或者说最后一层会影响调用位置。
~~~js
function foo() {
  console.log( this.a );
}
var obj2 = {
  a: 42,
  foo: foo
};
var obj1 = {
  a: 2,
  obj2: obj2
};
obj1.obj2.foo(); // 42
~~~
最后一层是 obj2，所有输出 obj2 的 a 属性值。

#### this 隐式丢失
~~~js
function foo () {
  console.log(this.a)
}
var obj = {
  a: 2,
  foo: foo
}
var bar = obj.foo // 函数别名
var a = 'oops. global'
bar() // oops, global
~~~
虽然 bar 和 obj.foo 是同一个引用，但是实际上，它引用的是 foo 函数本身，因此 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定

一种更微妙、更常见的并且更加出乎意料的情况发生在传入回调函数时：
~~~js
function foo () {
  console.log(this.a)
}
function doFoo(fn) {
  // fn 其实引用的时 foo
  fn() // 调用位置
}
var obj = {
  a: 2,
  foo: foo
}
var a = 'oops, global'
doFoo(obj.foo) // oops global
~~~
参数传递的方式其实是一种隐式的赋值，因此，fn 其实还是对 foo 函数的引用，结果和上个例子一样。

如果把函数传入 JavaScript 内置函数会怎么样？

~~~js
function foo () {
  console.log(this.a)
}
var obj = {
  a: 2,
  foo: foo
}
var a = 'oops, global'
setTimeout(obj.foo, 100) // oops global
~~~
结果是一样的。因为传参数的方式是隐式的赋值，实际上就是执行了 var fn = obj.foo，然后执行了 fn()，显然又和上边的例子是一样的。

#### 显示绑定
~~~js
function foo(){
  console.log(this.a)
}
var obj = {
  a: 2
}
foo.call(obj) // 2
~~~
书上说的显示绑定就是指利用函数自带的 call(...) 和 apply(...) 方法，它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着调用函数时指定这个 this。
1. 硬绑定

但是，call 和 apply 解决了我们上边说的隐式丢失的问题吗？

~~~js
function foo() {
  console.log(this.a)
}
function doFoo(fn){
  fn()
}
var obj = {
  a: 2,
  foo: foo
}
var a = 'oops global'
doFoo.call(obj, obj.foo) // oops global
~~~
我们这里没有用 setTimeout 这一类内置函数，因为会报非法调用的错误。
最终结果来看，没有解决，那是为什么呢？我们来看下，虽然我们利用call绑定了调用函数 doFoo 的 this 指向 obj，但是，按照函数时赋值传参的规则，假设 var fn = obj.foo，所以我们在 doFoo 中实际是 fn() 这样调用函数的，解释还是和上边一样，是不带任何修饰的函数引用调用。我们这个时候就会想到，是不是只要再调用 foo 的时候改变 fn() 的 this 指向就可以了。
~~~js
function foo() {
  console.log(this.a)
}
function doFoo(fn){
  fn.call(obj) // 强制绑定 obj 调用
}
var obj = {
  a: 2,
  foo: foo
}
var a = 'oops global'
doFoo(obj.foo) // 2
~~~
看来我们的猜想没有错，我们来看下书上的写法：
~~~js
function foo() {
  console.log(this.a)
}
var obj = {
  a: 2
}
var bar = function () {
  foo.call(obj)
}
var a = 'oops global'
bar()
setTimeout(bar, 100) // 2
~~~
书上的写法更加直接，无论之后怎么调用 bar 都会 手动在 obj 上调用 foo，这种绑定是一种显示的强制绑定，称之为硬绑定。

硬绑定的典型场景就是创建一个包裹函数，传入所有的参数并且返回接收到的所有值：
~~~js
// foo 就是包裹函数
function foo(something) {
  console.log(this.a, something)
  return this.a + something
}
var obj = {
  a: 2
}
var bar = function () {
  // foo 就是包裹函数
  return foo.apply(obj, arguments)
}
var b = bar(3) // 2 3
console.log(b) // 5
~~~
另外一种是创建一个可以重复使用的函数，我们可以想象如果要创造一个 bar 函数来进行封装：
~~~js
function bind(obj, fn) {
  return function () {
    return fn.apply(obj, arguments)
  }
}
function foo(something) {
  console.log(this.a, something)
  return this.a + something
}
var obj = {
  a: 2
}
var bar = bind(obj, foo) 
var b = bar(3) // 2 3
console.log(b) // 5
~~~
没错这就是我们常用的 bind 函数的功能，因为硬绑定非常常用，所以，在 ES5 中提供了内置的方法 Function.prototype.bind 方法。
2. API 调用的'上下文'

JavaScript的许多库和内置函数都提供了一个可选的参数，通常称为上下文，效果和bind一样，比如：

~~~js
function foo () {
  console.log(this.a)
}
var obj = {
  a: 4
}
[1,2,3].forEach(foo, obj) // 4 4 4
[1,2,3].map(foo, obj) // 4 4 4
~~~
前提这个 foo 不能是 es6 的箭头函数，否则不能绑定 this

#### new 操作符绑定

使用 new 来调用函数，会自动执行下面的操作：

* 创建一个全新的对象
* 这个新对象会被执行原型链接
* 这个新对象会被绑定到函数调用的 this
* 如果函数没有返回其他对象，那么 new 表达式中的函数会调用自动返回的这个新对象

~~~js
function foo(a) {
this.a = a;
}
var bar = new foo(2);
console.log( bar.a ); // 2
~~~

### 四种绑定的优先级

1. 隐式绑定和显示绑定

~~~js
function foo () {
  console.log(this.a)
}
var obj1 = {
  a: 2,
  foo: foo
}
var obj2 = {
  a: 3,
  foo: foo
}
obj1.foo() // 2
obj2.foo() // 3

obj1.foo.call(obj2) // 3
obj2.foo.call(obj1) // 2
~~~
显示绑定 > 隐式绑定

2. 隐式绑定和 new 绑定

~~~js
function foo(something) {
  this.a = something
}
var obj1 = {
  foo: foo
}

obj1.foo(1)
console.log(obj1.a) // 1

var bar = new obj1.foo(4)
console.log(obj1.a) // 1
console.log(bar.a) // 4
~~~
可以看出 new 绑定 > 隐式绑定

3. new 绑定与显示绑定

一般的显示绑定无法和 new 比较，因为无法通过 new foo.call(obj)，但是，可以通过硬绑定进行测试。

~~~js
function foo(something) {
  this.a = something
}
var obj = {
  foo: foo
}
obj.foo(1)
console.log(obj.a) // 1
var bar = new (foo.bind(obj, 2))
console.log(bar.a) // 2
~~~
结果是 new 绑定 > 硬绑定，我们拿上边硬绑定那一节写的 bind 来看下
~~~js
function foo(something) {
  this.a = something
}
function bind(obj, fn) {
  return function () {
    return fn.apply(obj, arguments)
  }
}
var obj = {
  foo: foo
}
obj.foo(1)
console.log(obj.a) // 1
var bar = bind(obj, foo)
var baz = new bar(2)
console.log(baz.a) // undefined
console.log(obj.a) // 2
~~~
显然无法改变 this 的指向，所以，JavaScript 内置的 bind 在内部肯定还有其他的实现。

因为 bind 是在 es5 才加入 JavaScript内置语法，所以，有些浏览器还需要做兼容性处理，下边是 mdn 上一种 bind 的 Pollyfill 实现：
~~~js
if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }
    var aArgs   = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP    = function() {},
        fBound  = function() {
          // this instanceof fNOP === true时,说明返回的fBound被当做new的构造函数调用
          return fToBind.apply(this instanceof fNOP
                 ? this
                 : oThis,
                 // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的
                 aArgs.concat(Array.prototype.slice.call(arguments)));
        };
      // 维护原型关系
    if (this.prototype) {
      // Function.prototype doesn't have a prototype property
      fNOP.prototype = this.prototype; 
    }
    // 下行的代码使fBound.prototype是fNOP的实例,因此
    // 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例
    fBound.prototype = new fNOP();

    return fBound;
  }
}
~~~

针对上边的判断使用哪个 this 的写法目前还不理解，估计得等看完原型那块内容。

#### 如何判断 this
1. 函数是否在 new 中调用（ new 绑定）？如果是的话 this 绑定的是新创建的对象。
  var bar = new foo()
2. 函数是否通过 call 、 apply （显式绑定）或者硬绑定调用？如果是的话， this 绑定的是指定的对象。
var bar = foo.call(obj2)
3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话， this 绑定的是那个上
下文对象。
var bar = obj1.foo()
4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined ，否则绑定到
全局对象。
var bar = foo()

### 绑定例外

#### 被忽略的 this

在某些情况下进行显示绑定将 this 指定为 null，如果调用的函数确实不关心 this 是没有什么问题，但是，如果使用到 this，那么有可能造成内部错误，尤其是针对第三方的库，这种方式可能会导致许多难以分析和追踪的 bug。

#### 更加安全的 this 

DMZ 空的非委托对象，这个概念目前还没理解~~~

#### 间接引用

另一个需要注意的是，你有可能（有意或者无意地）创建一个函数的“间接引用”，在这
种情况下，调用这个函数会应用默认绑定规则。
间接引用最容易在赋值时发生：
~~~js
function foo() {
  console.log( this.a );
}
var a = 2;
var o = { a: 3, foo: foo };
var p = { a: 4 };
o.foo(); // 3
(p.foo = o.foo)(); // 2
~~~
赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是
p.foo() 或者 o.foo() 。根据我们之前说过的，这里会应用默认绑定。

#### 软绑定

就是指给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改 this 的能力。

~~~js
if (!Function.prototype.softBind) {
  Function.prototype.softBind = function (obj) {
    var fn = this
    var curried = [].slice.call(arguments, 1)
    var bound = function () {
      return fn.apply(
        (!this || this === (window || global) ? obj: this),
        curried.concat.apply(curried, arguments)
      )
    }
    bound.prototype = Object.create(fn.prototype)
    return bound
  }
}
~~~

### this 词法

上述的四种规则适合所有的正常函数，但是，es6 的箭头函数不适用 this 的四种规则，而是根据外层（函数或者全局的作用域来决定）
~~~js
function foo() {
// 返回一个箭头函数
  return (a) => {
    //this 继承自 foo()
    console.log( this.a );
  };
}
var obj1 = {
  a:2
};
var obj2 = {
  a:3
  100 
};
var bar = foo.call( obj1 ); // 箭头函数已经捕获 this 为 obj1，箭头函数的this绑定无法被改变
bar.call( obj2 ); // 2, 不是 3 ！
~~~

## 对象
### 语法
~~~js
// 第一种
var obj = {}
// 第二种
var obj = new Object()
~~~
### 类型
JavaScript主要有六种类型
* string
* number
* boolean
* null
* undefined
* object

简单基本类型（ string 、 boolean 、 number 、 null 和 undefined ）本身并不是对象。

null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行
typeof null 时会返回字符串 "object" 。 1 实际上， null 本身是基本类型。
有一种常见的错误说法是“JavaScript 中万物皆是对象”，这显然是错误的。

实际上，JavaScript 中有许多特殊的对象子类型，我们可以称之为复杂基本类型。
函数就是对象的一个子类型（从技术角度来说就是“可调用的对象”）。JavaScript 中的函
数是“一等公民”，因为它们本质上和普通的对象一样（只是可以调用），所以可以像操作
其他对象一样操作函数（比如当作另一个函数的参数）。

数组也是对象的一种类型，具备一些额外的行为。数组中内容的组织方式比一般的对象要
稍微复杂一些。

### 内置对象

~~~js
* String
* Number
* Boolean
* Object
* Function
* Array
* Date
* RegExp
* Error
~~~

在JavaScript中他们只是一些内置函数，可以当做构造函数来使用。

~~~js
var strPrimitive = "I am a string";
console.log( strPrimitive.length ); // 13
console.log( strPrimitive.charAt( 3 ) ); // "m"
~~~
javascript引擎会自动将字面量转换成String对象，所以可以访问属性和方法。同样适用于数值字面量。

### 内容

获取属性值的方法有两种
~~~js
// 属性访问
.key
// 键访问
[key]
~~~

#### 可就算属性名

ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名
~~~js
var prefix = "foo";
var myObject = {
[prefix + "bar"]:"hello",
[prefix + "baz"]: "world"
};
myObject["foobar"]; // hello
myObject["foobaz"]; // world
~~~

#### 复制对象

~~~js
function anotherFunction() { /*..*/ }
var anotherObject = {
  c: true
};
var anotherArray = [];
var myObject = {
  a: 2,
  b: anotherObject, // 引用，不是复本！
  c: anotherArray, // 另一个引用！
  d: anotherFunction
};
anotherArray.push( anotherObject, myObject );

// 浅复制
var newObj = Object.assign( {}, myObject );
~~~

深复制还需要注意循环引用的问题。

#### 属性描述符

从 ES5 开始，所有的属性都具备了属性描述符

~~~js
var myObject = {
  a:2
};
Object.getOwnPropertyDescriptor( myObject, "a" );
// {
// value: 2,
// writable: true,
// enumerable: true,
// configurable: true
// }
~~~

通过 Object.getOwnPropertyDescriptor(...) 可以获取属性的描述对象，包含 value（属性值），writable（可写的），enumerable（可枚举），configurable（可配置）

在创建普通属性时，属性描述符会使用默认值，可以通过 Object.defineProperty(...)针对上边的几个值来进行设置。

~~~js
var myObject = {};
Object.defineProperty( myObject, "a", {
  value: 2,
  writable: true,
  configurable: true,
  enumerable: true
} );
myObject.a; // 2
~~~

1. writable

控制属性值是否能被写入，设置为 false 时，将无法对属性进行赋值操作。

2. configurable

控制属性值是否可以被配置。也就是说对于可配置的属性值，将其configurable设置为false，那么无法再次使用 Object.defineProperty(...)来将configurable设置为 true，把 configurable 修改成
false 是单向操作，无法撤销！
> 要注意有一个小小的例外：即便属性是 configurable:false ， 我们还是可以
> 把 writable 的状态由 true 改为 false ，但是无法由 false 改为 true 。

除了无法修改， configurable:false 还会禁止删除这个属性
~~~js
var myObject = {
  a:2
};
myObject.a; // 2
delete myObject.a;
myObject.a; // undefined
Object.defineProperty( myObject, "a", {
  value: 2,
  writable: true,
  configurable: false,
  enumerable: true
} );
myObject.a; // 2
delete myObject.a;
myObject.a; // 2
~~~

在本例中， delete 只用来直接删除对象的（可删除）属性。如果对象的某个属性是某个
对象 / 函数的最后一个引用者，对这个属性执行 delete 操作之后，这个未引用的对象 / 函数就可以被垃圾回收。但是，不要把 delete 看作一个释放内存的工具（就像 C/C++ 中那
样），它就是一个删除对象属性的操作，仅此而已。

3.  Enumerable

这个描述符控制的是属性是否会出现在对象的属性枚举中，比如说
for..in 循环。如果把 enumerable 设置成 false ，这个属性就不会出现在枚举中，虽然仍
然可以正常访问它。相对地，设置成 true 就会让它出现在枚举中。

#### 不变性

有时候你会希望属性或者对象是不可改变（无论有意还是无意）的，在 ES5 中可以通过很
多种方法来实现。

很重要的一点是，所有的方法创建的都是浅不变形，也就是说，它们只会影响目标对象和
它的直接属性。如果目标对象引用了其他对象（数组、对象、函数，等），其他对象的内
容不受影响，仍然是可变的：

1. 对象常量
结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性（不可修改、
重定义或者删除）：
~~~js
var obj1 = {a: 123}
var obj2 = {b: obj1}
Object.defineProperty(obj2, 'b', {writable: false, configurable: false})
obj1.a = 456
console.log(obj2.b) // 456
~~~
无法直接通过 obj2.b = ... 写入，但是，可以改变 obj2.b 的引用对象

2. 禁止扩展

如果你想禁止一个对象添加新属性并且保留已有属性，可以使用 Object.prevent
Extensions(..) ：

~~~js
var myObject = {
  a:2
};
Object.preventExtensions( myObject );
myObject.b = 3;
myObject.b; // undefined
~~~
在非严格模式下，创建属性 b 会静默失败。在严格模式下，将会抛出 TypeError 错误。

3. 密封

Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用
Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false 。

所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以
修改属性的值）。

4. 冻结

Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用
Object.seal(..) 并把所有“数据访问”属性标记为 writable:false ，这样就无法修改它们
的值。

这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意
直接属性的修改（不过就像我们之前说过的，这个对象引用的其他对象是不受影响的）。
你可以“深度冻结”一个对象，具体方法为，首先在这个对象上调用 Object.freeze(..) ，
然后遍历它引用的所有对象并在这些对象上调用 Object.freeze(..) 。但是一定要小心，因
为这样做有可能会在无意中冻结其他（共享）对象。

### getter 和 setter

在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法
应用在整个对象上。getter 是一个隐藏函数，会在获取属性值时调用。setter 也是一个隐藏
函数，会在设置属性值时调用。

当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为“访问描述
符”（和“数据描述符”相对）。对于访问描述符来说，JavaScript 会忽略它们的 value 和
writable 特性，取而代之的是关心 set 和 get （还有 configurable 和 enumerable ）特性。

~~~js
var myObject = {
// 给 a 定义一个 getter
  get a() {
    return 2;
  }
};
Object.defineProperty(
myObject, // 目标对象
"b", // 属性名
  { // 描述符
    // 给 b 设置一个 getter
    get: function(){ return this.a * 2 },
    // 确保 b 会出现在对象的属性列表中
    enumerable: true
  }
);
myObject.a; // 2
myObject.b; // 4
~~~

### 存在性

通过 obj.key 访问属性的返回值可能是 undefined，但是这个值可能是对象中属性值为 undefined，或者不存在这个属性。

~~~js
var myObject = {
a:2
};
("a" in myObject); // true
("b" in myObject); // false
myObject.hasOwnProperty( "a" ); // true
myObject.hasOwnProperty( "b" ); // false
~~~
in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中，相比之下，
hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链

但是如果是针对Object.create(null) 的对象，是无法调用 hasOwnProperty 的，可以通过
~~~js
 Object.prototype.hasOwnProperty.call(myObject,"a") 
~~~
它借用基础的 hasOwnProperty(..) 方法并把它显式绑定到 myObject 上

in 操作符和 hasOwnProperty 无论属性是否可枚举都可以找到，那么如何区分属性是不是可枚举呢？

* for ... in 不会遍历不可枚举的属性
* propertyIsEnumerable(...) 会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足 enumerable:true 。

Object.keys(..) 会返回一个数组，包含所有可枚举属性， Object.getOwnPropertyNames(..)会返回一个数组，包含所有属性，无论它们是否可枚举。

in 和 hasOwnProperty(..) 的区别在于是否查找 [[Prototype]] 链，然而，Object.keys(..)和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性。
