# 第一部分

## 第一章 作用域是什么？

存储和查找变量的规则。

### 1.1 编译原理：
* JavaScript实际上一门编译语言。任何JavaScript的代码在执行前都要进行编译。大部分的编译发生在代码执行前的几微妙（甚至更短）。
* 编译的三个过程：
  * 分词/词法分析
  * 解析/语法分析
  * 代码生成

### 1.2 作用域的理解
* 对 JavaScript 代码进行处理时需要参与的三个成员 引擎，编译器，作用域以及它们分别的作用。
* 作用域参与编译器和引擎的工作，协助编译器和引擎存储和查找变量

### 1.3 作用域嵌套
* 遍历嵌套作用域链的规则：引擎从当前的执行作用域开始查找变量，如果找不到，
就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都
会停止。

### 1.4 异常
在普通模式下，执行 LHS 查询，如果直到顶层作用域都无法找到所需的变量，会在顶层作用域，隐式的创建一个。执行 RHS 查询，在所有的嵌套作用中，无法找到需要的变量，引擎会抛出 ReferenceError 异常。
在严格模式下（'use strict'），执行 LHS 查询，如果直到顶层作用域都无法找到所需的变量，不会在顶层作用域隐式的创建一个，引擎会抛出 ReferenceError 异常，因为严格模式不允许隐式创建变量。

---

## 第二章 词法作用域
作用域共有两种主要的工作模型，第一种最为普遍，被大多数编程语言所采用的词法作用域。另外一种叫做动态作用域，仍有一些编程语言在使用。JavaScript所采用的模型是词法作用域。
举个例子说明动态作用域和词法作用域的区别：
~~~js
function foo () {
  console.log(a)
}
function bar () {
  var a = 3
  foo()
}
var a = 2
bar() // 2
~~~
上边的代码 js 会输出 2，因为 foo 函数的 RHS 查找变量是通过全局的作用域进行查找的
如果 js 是动态语言，那么结果就会输出 3，动态作用域不关心函数是在何处声明的，只关心在何处调用。
### 2.1 词法阶段
在之前的[1.1编译原理](###1.1编译原理)中提到编译器工作的三个阶段，第一个是词法分析，大部分标准编译器的第一个工作阶段叫做词法化。
**简单的来说，词法作用域就是定义在词法阶段的作用域。换句话来说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，由此，当词法分析器处理代码时，会保持作用域不变**
### 2.2 词法欺骗
刚才所说，词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”（欺骗），词法作用域？

JavaScript 中有两种方式：eval 和 with

#### 2.2.1 eval
eval 函数可以接收一个字符串为参数，并且将其中内容作为好像在书写时就在当前位置的代码来执行。请看下面例子：
~~~js
function foo (str) {
  eval(str)
  console.log(a)
}
var a = 1
foo("var a = 3") // 3
~~~
eval 常用来动态创建代码，但是，在严格模式中，eval(...) 在运行时有其自己的作用域，意味着无法修改所在地作用域。
~~~js
function foo (str) {
  eval(str)
  console.log(a) // ReferenceError: a is not defined
}
foo("var a = 3") 
~~~
setTimeout(...) 和 setInterval(...) 的第一个参数可以是字符串，字符串的代码可以解释成正确的代码执行。这些功能已经过时，不要使用它。

new Function(...) 函数最后一个参数可以接收代码字符串，并且将其转化成动态代码。这种做法比eval(...)略微安全，但是，也要尽量避免使用。

#### with




