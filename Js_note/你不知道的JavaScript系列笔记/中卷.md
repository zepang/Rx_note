# 第一部分 类型和语法
## 第一章 类型

要正确合理地进行类型转换（参见第 4 章），我们必须掌握 JavaScript 中的各个类型及其内在行为。几乎所有的 JavaScript 程序都会涉及某种形式的强制类型转换，处理这些情况时
我们需要有充分的把握和自信。

### 内置类型

上卷第二部分对象一章提到JavaScript的类型有6种，然而这里提到了7种：
* 空值(null)
* 未定义(undefined)
* 布尔值(boolean)
* 数字(number)
* 字符串(string)
* 对象(object)
* 符号(symbol, ES6 新增)

> 除对象之外，其他统称为“基本类型”。

我们可以使用 typeof 运算符来查看值的类型：

~~~js
typeof undefined === "undefined"; // true
typeof true === "boolean"; // true
typeof 42 === "number"; // true
typeof "42" === "string"; // true
typeof { life: 42 } === "object"; // true
// ES6中新加入的类型
typeof Symbol() === "symbol"; // true
~~~

以上6种类型都有相应的字符串值与之相呼应，但是不包括 null

~~~js
typeof null === 'object'
~~~

正确的返回结果应该是 "null" ，但这个 bug 由来已久，在 JavaScript 中已经存在了将近
二十年，也许永远也不会修复，因为这牵涉到太多的 Web 系统，“修复”它会产生更多的
bug，令许多系统无法正常工作。

我们需要复合条件来检测 null：
~~~js
(!null && null === 'object')
~~~

还有一种情况：

~~~js
typeof function a(){ /* .. */ } === "function"; // true
~~~
function （函数）也是 JavaScript 的一个内置类型。然而查阅规范就会知道，
它实际上是 object 的一个“子类型”。具体来说，函数是“可调用对象”，它有一个内部属
性 [[Call]] ，该属性使其可以被调用。

函数不仅是对象，还可以拥有属性：
~~~js
function foo (a, b) {/.../}
foo.length // 2
~~~
函数的 length 属性值是其参数的个数

让我们看看数组：
~~~js
typeof [1,2,3] === 'object' //true
~~~

数组也是对象。确切地说，它也是 object 的一个“子类型”（参见第 3 章），数组的
元素按数字顺序来进行索引（而非普通像对象那样通过字符串键值），其 length 属性是元
素的个数。

### 值和类型

**JavaScript 的变量是没有类型的，只有值才有。变量可以持有任何类型的值。**

换个角度来理解就是，JavaScript 不做“类型强制”；也就是说，语言引擎不要求变量总是
持有与其初始值同类型的值。一个变量可以现在被赋值为字符串类型值，随后又被赋值为
数字类型值。

### undefined 和 undeclared

变量在未持有值的时候是 undefined。

在作用域中未声明变量时未 undeclared

~~~js
var a;
a; // undefined
b; // ReferenceError: b is not defined
~~~
通常变量在未定义的情况下使用会报 is not defined 的错误，但是有时候却不是，但是 typeof 的处理方式却不是这样：
~~~js
var a ;
typeof a // undefined
typeof b // undefined
~~~
对于 undeclared（或者 not defined）变量， typeof 照样返回 "undefined" 。请注意虽然 b 是
一个 undeclared 变量，但 typeof b 并没有报错。这是因为 typeof 有一个特殊的安全防范机制。

之前在上卷中也提到一个问题，对象取值的时候有可能返回 undefined，但是我们也不能根据 undefined 来判断，对象是因为不存在这个属性还是对象属性值为 undefined.

#### typeOf Undeclared

typeOf 这种防范机制在某些情况下是十分有作用的，比如判断全局的变量是否存在：
~~~js
// 这样判断会报错，会中断代码
if (DEBUG) {...}
// 但是换成 typeOf 来判断是安全的，不存在的时候只会抛出一个 undefined 
if (typeOf DEBUG !== undefined) {...}
~~~

当然你也可以这样写，可以不通过 typeOf:
~~~js
if (window.DEBUG) {
// ..
}
if (!window.atob) {
// ..
}
~~~
因为访问属性，就算不存在这个属性也会返回 undefined

---

## 值
### 数组
和其他强类型语言不同，在 JavaScript 中，数组可以容纳任何类型的值，可以是字符串、
数字、对象（ object ），甚至是其他数组（多维数组就是通过这种方式来实现的）

对数组声明后即可向其中加入值，不需要预先设定大小

~~~js
var a = [ ];
a.length; // 0
a[0] = 1;
a[1] = "2";
a[2] = [ 3 ];
a.length; // 3
~~~

使用 delete 运算符可以将单元从数组中删除，但是请注意，单元删除后，数
组的 length 属性并不会发生变化。第 5 章将详细介绍 delete 运算符。

数组是通过数字进行索引，但是数组也是对象，所以也可以包含字符串键值和属性

~~~js
var arr = []
arr['foo'] = 2
arr.length // 0
arr['12'] = 2
arr.length // 13
arr // [empty X 12, 2, foo: 2]
~~~
用字符串键值对存储，数组的 length 不会产生变化，但是需要注意的是，字符串如果被强制转换成十进制的话，它会被当成数字索引来处理，所以上边的 arr['12']就被当初了 arr[12]，所以，数组的length 变化为13

### 类数组
例如一些 dom 查询会返回 dom 元素列表，或者是 arguments 对象访问函数的参数列表，它们不是正在意义上的数组，但是与数组十分类似。通过工具函数可以将这些类数组转换成真正的数组。

工具函数 slice 经常被用于这类转换：

~~~js
function foo() {
  var arr = Array.prototype.slice(arguments)
  arr.push('bam)
  console.log(arr)
}
foo('bar', 'baz') // ['bar', 'baz', 'bam']
~~~

用 ES6 中的内置工具函数 Array.from(..) 也能实现同样的功能：

~~~js
var arr = Array.from( arguments );
~~~
> Array.from(..) 有一些非常强大的功能，将在本系列的《你不知道的JavaScript（下卷）》的“ES6 & Beyond”部分详细介绍。

### 字符串

字符串经常被当成字符数组。字符串的内部实现究竟有没有使用数组并不好说，但
JavaScript 中的字符串和字符数组并不是一回事，最多只是看上去相似而已。

字符串和数组的确很相似，它们都是类数组，都有 length 属性以及 indexOf(..) （从 ES5
开始数组支持此方法）和 concat(..) 方法：

~~~js
var a = "foo";
var b = ["f","o","o"];

a.length; // 3
b.length; // 3

a.indexOf( "o" ); // 1
b.indexOf( "o" ); // 1
var c = a.concat( "bar" ); // "foobar"
var d = b.concat( ["b","a","r"] ); // ["f","o","o","b","a","r"]
a === c; // false
b === d; // false
a; // "foo"
b; // ["f","o","o"]
~~~

但这并不意味着它们都是“字符数组”，比如：
~~~js
a[1] = "O";
b[1] = "O";
a; // "foo"
b; // ["f","O","o"]
~~~
JavaScript 中的字符串是不可变的，但是数组是可变的。

字符串不可变是指字符串的成员函数不会改变字符串的原始值，而是创建并且返回一个新的字符串。而数组的成员函数都是在其原始值进行操作的。

~~~js
c = a.toUpperCase();
a === c; // false
a; // "foo"
c; // "FOO"
b.push( "!" );
b; // ["f","O","o","!"]
~~~

许多数组函数用来处理字符串很方便。虽然字符串没有这些函数，但可以通过“借用”数
组的非变更方法来处理字符串：
~~~js
a.join // undefined
a.map // undefined

var c = Array.prototype.join(a, '-') // f-o-o
var d = Array.prototype.map(a, (v) => {
  return v.toUpperCase() + '.'
}).join('') // F.O.O
~~~
数组有一个成员函数 reverse()，这个函数目前无法借用，想要进行字符串的反转，可以先将字符串转换成数组：
~~~js
var c = a.split('').reverse().join('')
~~~

### 数字

JavaScript 只有一种数字类型：number（数字），包括“整数”和带小数的十进制数。“整数”之所以加引号是因为和其他语言不同，JavaScript 没有真正意义上的整数，这也是
它一直以来为人诟病的地方。这种情况在将来或许会有所改观，但目前只有数字类型。
JavaScript 中的“整数”就是没有小数的十进制数。

#### 数字的语法

JavaScript 中的数字常量一般用十进制来表示。
~~~js
var a = 42
var b = 42.3
~~~
数字前面的 0 和 小数点后小数部分后面的 0 可以去掉
~~~js
var a = 0.32
var a = .32

var a = 43.0
var a = 43
~~~
特别大和特别小的数字默认用指数格式显示，与 toExponential() 函数的输出结果相同。
~~~js
var a = 5E10;
a; // 50000000000
a.toExponential(); // "5e+10"
var b = a * a;
b; // 2.5e+21
var c = 1 / a;
c; // 2e-11
~~~
tofixed(..) 方法可指定小数部分的显示位数：
~~~js
var a = 42.59;
a.toFixed( 0 ); // "43"
a.toFixed( 1 ); // "42.6"
a.toFixed( 2 ); // "42.59"
a.toFixed( 3 ); // "42.590"
a.toFixed( 4 ); // "42.5900"
~~~
toPrecision(..) 方法用来指定有效数位的显示位数：
~~~js
var a = 42.59;
a.toPrecision( 1 ); // "4e+1"
a.toPrecision( 2 ); // "43"
a.toPrecision( 3 ); // "42.6"
a.toPrecision( 4 ); // "42.59"
a.toPrecision( 5 ); // "42.590"
a.toPrecision( 6 ); // "42.5900"
~~~
上面的方法不仅适用于数字变量，也适用于数字常量。不过对于 . 运算符需要给予特别注
意，因为它是一个有效的数字字符，会被优先识别为数字常量的一部分，然后才是对象属
性访问运算符。

~~~js
// 无效语法：
42.toFixed( 3 ); // SyntaxError
// 下面的语法都有效：
(42).toFixed( 3 ); // "42.000"
0.42.toFixed( 3 ); // "0.420"
42..toFixed( 3 ); // "42.000"
~~~
42.tofixed(3) 是无效语法，因为 . 被视为常量 42. 的一部分（如前所述），所以没有 . 属性访问运算符来调用 tofixed 方法。
42..tofixed(3) 则没有问题，因为第一个 . 被视为 number 的一部分，第二个 . 是属性访问运算符。只是这样看着奇怪，实际情况中也很少见。在基本类型值上直接调用的方法并不
多见，不过这并不代表不好或不对。

#### 较小的数值
二进制浮点数最大的问题（不仅 JavaScript，所有遵循 IEEE 754 规范的语言都是如此），是会出现如下情况：
~~~js
0.1 + 0.2 === 0.3; // false
~~~
从数学角度来说，上面的条件判断应该为 true ，可结果为什么是 false 呢？
简单来说，二进制浮点数中的 0.1 和 0.2 并不是十分精确，它们相加的结果并非刚好等于
0.3 ，而是一个比较接近的数字 0.30000000000000004 ，所以条件判断结果为 false 。

那么应该怎样来判断 0.1 + 0.2 和 0.3 是否相等呢？
最常见的方法是设置一个误差范围值，通常称为“机器精度”（machine epsilon），对
JavaScript 的数字来说，这个值通常是 2^-52 (2.220446049250313e-16) 。

从 ES6 开始，这个值就定义在Number.EPSILON中，我们可以直接使用，也可以用 polyfill:
~~~js
if (!Number.EPSILON) {
  Number.EPSILON = Math.pow(2,-52);
}

function numbersCloseEnoughToEqual(n1,n2) {
  return Math.abs( n1 - n2 ) < Number.EPSILON;
}
var a = 0.1 + 0.2;
var b = 0.3;
numbersCloseEnoughToEqual( a, b ); // true
numbersCloseEnoughToEqual( 0.0000001, 0.0000002 ); // false
~~~
能够呈现的最大浮点数大约是 1.798e+308 （这是一个相当大的数字），它定义在 Number.
MAX_VALUE 中。最小浮点数定义在 Number.MIN_VALUE 中，大约是 5e-324 ，它不是负数，但无限接近于 0 ！

#### 整数的安全范围

能够被“安全”呈现的最大整数是 2^53 - 1 ，即 9007199254740991 ，在 ES6 中被定义为
Number.MAX_SAFE_INTEGER 。最小整数是 -9007199254740991 ，在 ES6 中被定义为 Number.MIN_SAFE_INTEGER 。

有时 JavaScript 程序需要处理一些比较大的数字，如数据库中的 64 位 ID 等。由于
JavaScript 的数字类型无法精确呈现 64 位数值，所以必须将它们保存（转换）为字符串。
好在大数值操作并不常见（它们的比较操作可以通过字符串来实现）。如果确实需要对大
数值进行数学运算，目前还是需要借助相关的工具库。将来 JavaScript 也许会加入对大数
值的支持。

#### 整数检测

要检测一个数字是否为整数，可以使用 ES6 的 Number.isInterger(...)

~~~js
Number.isInteger( 42 ); // true
Number.isInteger( 42.000 ); // true
Number.isInteger( 42.3 ); // false
~~~

也可以为 ES6 之前的版本 polyfill  Number.isInteger(..) 方法：
~~~js
if (!Number.isInteger) {
  Number.isInteger = function(num) {
    return typeof num == "number" && num % 1 == 0;
  };
}
~~~
要检测一个值是否是安全的整数，可以使用 ES6 中的 Number.isSafeInteger(..) 方法：
~~~js
Number.isSafeInteger( Number.MAX_SAFE_INTEGER ); // true
Number.isSafeInteger( Math.pow( 2, 53 ) ); // false
Number.isSafeInteger( Math.pow( 2, 53 ) - 1 ); // true
~~~
可以为 ES6 之前的版本 polyfill  Number.isSafeInteger(..) 方法：
~~~js
if (!Number.isSafeInteger) {
  Number.isSafeInteger = function(num) {
    return Number.isInteger( num ) &&
    Math.abs( num ) <= Number.MAX_SAFE_INTEGER;
  };
}
~~~

### 特殊数值

JavaScript的数据类型中有几个特殊的值需要开发人员特别注意和小心使用

#### 不是值的值

undefined 类型只有一个值，即 undefined。null类型也只有一个值，即 null。它们的名称既是类型也是值。

undefined 和 null 通常被用来表示“空的”或者“不是值”的值，二者之间有一些细微的差别：

* null 指空值
* undefined 指没有值

或者

* undefined 指从没有赋过值
* null 指曾赋过值，但是目前没有值

null 是一个特殊的关键字，不是标识符，我们不能将其当作变量来使用和赋值，然而，undefined 却是一个标识符，可以被当作变量来使用和赋值

#### undefined
非严格模式下，我们可以为全局的标识符 undefined 赋值。
~~~js
function foo () {
  undefined = 2
}
foo () 
function foo(){
  "use strict";
  undefined = 2 // TypeError
}
foo()
~~~
#### void 运算符
undefined 是一个内置标识符（除非被重新定义，见前面的介绍）它的值为 undefined，通过 void 运算符即可得到该值。

~~~js
var a = 42
console.log(vaid a, a) // undefined 42
~~~
按照惯例我们使用 void 0 来获得 undefined 。void 0 void 1 和 undefined 之间并没有实质的区别

此外，void 还可不让表达式返回任何结果

~~~js
function doSomething() {
  if (!APP.ready) {
    return void setTimeout(doSomething, 100)
  }
  var result 
  return result
}
if (doSomething) {
  // 立即执行下一个任务
~~~
很多的开发人员喜欢分开操作：
~~~js
if (!APP.ready) {
  setTimeout(doSomething, 100)
  return 
}
~~~

#### 特殊的数字

如果数学运算符的操作数不是数字类型，就无法返回一个有效的数字，这种情况下返回值为 NaN

NaN 指“不是一个数字”，我们可以将它理解为“无效的数值”“失败的数值”“坏数值”
~~~js
var a = 2 / 'foo' // NaN
typeof NaN // number
~~~
换句话来说，“不是数字的数字：仍然是数字类型。
~~~js
var a = 2 / 'foo' // NaN
a === NaN // false
isNaN(a) // true
~~~
NaN 是一个特殊值，他是JavaScript中唯一一个不等于自身的值。我们通常通过一个全局函数 isNaN(...) 来判断一个值是不是 NaN。

然而，isNaN(...)有一个严重的缺陷，上边我们说了 NaN 的类型还是一个数字类型：
~~~js
var b  = 'foo'
isNaN(b) // true
~~~
显然 b 是一个字符串不是一个数字类型，所以不能是NaN，这个bug自JavaScript来一直存在。

从 ES6 开始我们可以使用工具函数 Number.isNaN(...)。在 ES6 之前我们可以使用浏览器的 polyfill：
~~~js
if (!Number.isNaN) {
  Number.isNaN = function (n) {
    return {
      typeof n === 'number' && window.isNaN(n)
    }
  }
}
~~~

我们也可以利用 NaN 是JavaScript中唯一一个不等于自身的特点来写这个 polyfill:
~~~js
if (!Number.isNaN) {
  Number.isNaN = function (n) {
    return n ! == n
  }
}
~~~
#### 无穷数
~~~js
var a = 1 / 0 //Infinity
var b = -1 / 0 // -Infinity
~~~
Infinity 即 Number.POSITIVE_INFINITY
-Infinity 即 Number.NAGATIVE_INFINITY

#### 零值

~~~js
var a = 0 / -3 // -0
var a = 0 * -3 // -0
~~~
javaScript 中的除法和乘法会得到 -0，但是加法和减法不会得到 -0.
~~~js
var a = -0
a.toString() // '0'
a + '' // '0'
JSON.stringify(a) // '0'
~~~
我们将 -0 转换为字符串可以得到字符串 '0'
~~~js
+ '-0'; //-0
Number('-0') // -0
JSON.parse('-0') // -0
~~~

~~~js
-0 === 0 //true
-0 > 0 //false
~~~
如何区分 0 和 -0
~~~js
function isNegZero(n) {
  n = Number(n)
  return (n === 0) && (1/n === -Infinity)
}
~~~

#### 特殊等式
如前面所述，NaN 和 -0 在相等比较的时候比较特别，所以，需要借助 Number.isNaN(...)或者是isNegZero(...) 这样的工具函数来比较。

ES6 中加入了一个新的方法 Object.is(...) 来判断两个值是否绝对相等。
~~~js
var a = 2 / 'foo'
var b = -3 * 0
Object.is(a, NaN) // true
Object.is(b, -0) // true
Object.is(b, 0) // true
~~~

对于 ES6 之前的版本，Object.is(...) 有一个简单的polyfill:
~~~js
if (!Object.is) {
  Object.is = function (v1, v2) {
    // 判断是否是 -0
    if (v1 === 0 && v2 === 0) {
      return 1 / v1 ==== 1 / v2
    }
    // 判断是否是NaN
    if (v1 !== v2) {
      return v2 !== v2
    }
    return v1 === v2
  }
}
~~~
> 能使用 == 和 === 就不要使用 Object.is(...) 因为前者的效率比较高。

### 值和引用

JavaScript对值和引用的赋值/船体在语法上没有区别，完全根据值的类型来决定。
~~~js
var a = 2
var b = a // b 是 a 的副本
b++
a // 2
b // 3

var c = [1,2,3]
var d = c
d.push(4)
c // [1,2,3,4]
d // [1,2,3,4]
~~~

**简单值（即是标量基本类型值）总是通过值复制的方式来赋值/传递，包括null, undefined,字符串，数字，布尔值和ES6中symbol**

**复合值---对象（包括组装和封装对象）和函数，则总通过引用扶植的方式来赋值/传递**

由于引用指向的是值本身而并非变量，所以一个引用无法更改另一个引用的指向。
~~~js
var a = [1,2,3]
var b = a
a // [1,2,3]
b // [1,2,3]

b = [4,5,6]
a // [1,2,3]
b // [4,5,6]
~~~

函数参数就经常让人产生这样的困惑：
~~~js
function foo(x) {
  x.push(4)
  x // [1,2,3,4]

  x = [4,5,6]
  x.push(7)
  x // [4,5,6,7]
}
var a = [1,2,3]
foo(a)
a // [1,2,3,4] 而不是 [4,5,6,7]
~~~

> 我们无法决定使用值复制还是引用复制，一切由值的类型来决定。

如果通过值赋值的方式来传递复合值，就需要为它创建一个复本。

如： foo(a.slice())，slice(...)能返回当前数组的一个浅复本。

相反的如果要将标量的基本类型值传递到函数内并进行更改，就需要将该值封装到一个复合值中，然后通过引用复制的方式进行传递。
~~~js
function foo(wrapper) {
  wrapper.a = 42
}
var obj = {
  a: 2
}
foo(obj) 
obj.a // 42
~~~

那是不是需要传递指向标量的基本类型值的引用，就可以将其风转告对应的对象中。
~~~js
function foo(x) {
  x = x + 1
  x //3
}
var a = 2
var b = new Number(a)
foo(b)
console.log(b) // 是 2，不是 3
~~~

原因是标量基本类型值是不可变的。

---

## 原生函数

常用的原生函数：
* String()
* Number()
* Boolean()
* Array()
* Object()
* Function()
* RegExp()
* Date()
* Error()
* Symbol() ---- ES6 新加入

原生函数可以当作构造函数来使用，但是其构造出来的对象可能会和我们设想的所有出入：

~~~js
var a = new String('abc')
typeof a // object
a instanceof String // true
Object.prototype.toString.call(a) //[object, String]
~~~
typeof 在这里返回的是对象的子类型

### 内部属性

所有 typeof 返回值为"object"的对象都包含一个内部属性，这个属性我们无法访问，一般通过Object.prototype.toString(...)来查看。

### 封装对象包装

封装对象扮演着十分重要的角色。由于基本类型值没有.length 和 .toString() 这样的属性和方法，需要通过风转对象才能访问，此时 JavaScript自动为基本类型值包装一个封装对象。

~~~js
var a = 'atbc'
a.length // 3
a.toUpperCase() // 'ABC'
~~~

#### 封装对象释疑
使用封装对象时有些地方需要特别注意

比如Boolean:
~~~js
var a = new Boolean(false)
if (!a) {
  console.log('Oops') // 执行不到这里
}
~~~

想要自行封装基本类型值，可以使用Object(...) 函数
~~~js
var a = 'abc'
var b = new String(a)
var c = Object(a)
typeof a // string
typeof b // object
typeof c // object

b instanceof String // true
c instanceof String // true

Object.prototype.toString.call(b) // '[object String]'
Object.prototype.toString.call(c) // '[object String]'
~~~
**一般不推荐世界使用封装对象**

### 拆封
如果需要得到封装中的基本类型值，可以使用 valueOf() 函数

~~~js
var a = new String('abc')
var b = new Number(42)
var c = new Boolean(true)

a.valueOf() // 'abc'
b.valueOf() // 42
c.valueOf() // true
~~~

在需要用到封装对象的基本类型值的地方会发生隐式拆封，即强制类型转换。在第四章当中会介绍。

### 将原生函数作为构造函数

关于数组（Array）、对象（Object）、函数（function）和正则表达式，我们通常喜欢以常量的形式来创建它们，效果实际上和使用构造函数是一样的，除非十分必要，否则不要使用构造函数。

#### Array(...)

~~~js
var a = new Array(1,2,3)
var b = Array(1,2,3)
a // [1,2,3]
b // [1,2,3]
~~~

构造函数Array(...)不要求必须 new 关键字，不带时，它会自动补上。

Array 构造函数只带一个数字参数时，该参数会被认为数组的长度来处理，而非只充当数组中的一个元素。

#### Object(...)、Function(...) 、和 RegExp(...)

#### Date(...) 和 Errro(...)

相对于其他的原生构造函数，Date(...)和Error(...)的用处要大很多，因为没有对应的常量形式来作为它们的代替。

创建日期对象必须使用 new Date(...)。Date(...)可以带参数，用来指定日期和时间，而不带参数的话则使用当前的日期和时间。

Date(...)主要用来获得当前的Unix时间戳（从1970年1月1日开始计算，以秒为单位。该值可以通过日期对象的getTime()来获得。

从 ES5 开始引入一个更简单的方法，Date.now()。对于ES5之前的版本可以使用：
~~~js
if (!Date.now) {
  Date.now = function () {
    return (new Date()).getTime()
  }
}
~~~

构造函数 Error(...)带不带 new 关键字都可以

错误对象只要是为了获得当前运行栈上下文。栈上下文信息包括函数调用栈信息和产生的错误代码行号，以便调式。

~~~js
function foo(x) {
  if (!x) {
    throw new Error("x wasn't provided")
  }
}
~~~

通常错误对象至少包含一个message属性。

除了 Error(...)之外，还有一些针对特定错误类型的原生构造函数，如：
EvalError(...)、RangeError(...)、ReferenceError(...)、SyntaxError(...)
、TypeError(...)和URIError(...)。这些构造函数很少使用，它们在程序发生异常时会被自动调用。

#### Symbol(...)

ES6 中新加入的有一个基本数据类型---符号。符号属性具有唯一性的特殊性（并非绝对），用它来命名对象属性不容易导致重名。

~~~js
var mysym = Symbol('my own symbo')
mysym // Symbol(my own symbol)
mysym.toString() // 'Symbol(my own symbol)'
typeof mysm // symbol

var a = {}
a[mysym] = 'foobar'

Object.getOwnPropertySymbols(a)
// [Symbol(my own symbol)]
~~~

Object.getOwnPropertySymbos(...)可以公开获得对象中的所有符号。符号通常用域私有属性。

---

## 第四章 强制类型转换

### 值类型转换
将值从一种类型转换为另一种类型通常称为类型转换，这是显示的情况，隐式的情况称为强制类型转换。

### 抽象值操作
介绍隐式和显示强制类型转换之前，我们需要掌握字符串、数字和布尔值之间的类型转换的规则。

#### toString()
* 基本值类型的字符串转换规则为：null 转换为 "null",undefined转换为"undefined",true转换为"true",数字的字符串遵循通用规则，不过第2章中讲过的那些极小和极大的数字使用指数形式：
~~~js
var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000
a.toString() // "1.07e21"
~~~

* 对于普通对象来讲，除非自行定义，否则toString()(Object.prototype.toString())返回内部属性[[Class]]的值。
然而我们在前面讲过，如果对象由中级的toString()方法，字符串化时就会调用该方法并且使用其返回值。

* 数组的默认toString() 方法经过了重新定义，将所有的单元字符串化后再用","连接起来：
~~~js
var a = [1,2,3]
a.toString() // '1,2,3'
~~~

##### JSON字符串化
工具函数JSON.stringify(...)在将JSON对象序列化为字符串时也用到了ToString

> 请注意，JSON字符串化并非严格意义上的强制类型转换，以为其中也涉及到ToString的相关规则。

* 对于大多数简单值，JSON字符串化和toString()的效果基本相同，只不过序列化的结果总是字符串：
~~~js
JSON.stringify(42) // '42'
JSON.stringify('42')// '42'
JSON.stringify(null)// 'null'
JSON.stringify(true) // 'true'
~~~
所有的安全的JSON值都可以使用JSON.stringify(...)字符串化。安全值是指可以呈现为有效JSON的值。

哪些是不安全的值：undefined、function、symbol和包含循环引用的对象都不符合JSON结构标准。

JSON.stringify(...) 在对象中遇到undefined、function和symbol时会自动将其忽略，在数组中会返回null（以保证单元位置不变）
~~~js
JSON.stringify(undefined) // undefined
JSON.stringify(function(){}) // undefined
JSON.stringify(
  [1, undefined, function(){}, 4]
) // "[1, null, null, 4]"
JSON.stringify(
  { a: 2, b: function(){} }
) // "{"a": 2}"
~~~
对包含循环引用的对象执行JSON.stringify(...)会报错

如果对象中定义了toJSON()方法，JSON字符串化时会首先调用该方法，然后用它的返回值来序列化。

如果要对含非法JSON值的对象做字符串化，或者对象中的某些值无法被序列化，就需要定义JSON()方法来返回一个安全的JSON值。

~~~js
var o = { };
var a = {
  b: 42,
  c: o,
  d: function(){}
};
// 在a中创建一个循环引用
o.e = a;
// 循环引用在这里会产生错误
// JSON.stringify( a );
// 自定义的JSON序列化
a.toJSON = function() {
// 序列化仅包含b
  return { b: this.b };
};
JSON.stringify( a ); // "{"b":42}"
~~~
很多人误认为toJSON返回的是JSON字符串化后的值，其实不是，toJSON()的返回值应该是一个适当的值，可以是任何类型，然后再用JSON.stringify(...)进行格式化。

我们可以向JSON.stringify(...)中传递一个可选择参数replacer，他可以是数组或者函数，用来指定对象序列化过程中，哪些属性应该被处理哪些应该被排除。

* 如果replacer是一个数组，那么它必须是一个字符串数组，其中包含要被处理的对象属性名称。
* 如果replacer是一个函数，它会对对象本身调用一次，然后对对象中的每个属性各调用一次，每次传递两个参数，键和值。如果要忽略某个键就返回 undefined ，否则返回指定的值。
~~~js
var a = {
  b: 42,
  c: "42",
  d: [1,2,3]
};
JSON.stringify( a, ["b","c"] ); // "{"b":42,"c":"42"}"
JSON.stringify( a, function(k,v){
  if (k !== "c") return v;
} );
// "{"b":42,"d":[1,2,3]}"
~~~

请记住， JSON.stringify(..) 并不是强制类型转换。在这里介绍是因为它涉及 ToString 强
制类型转换，具体表现在以下两点。

(1) 字符串、数字、布尔值和 null 的 JSON.stringify(..) 规则与 ToString 基本相同。

(2) 如果传递给 JSON.stringify(..) 的对象中定义了 toJSON() 方法，那么该方法会在字符
串化前调用，以便将对象转换为安全的 JSON 值。

#### ToNumber

有时我们需要将非数字值当作数字来使用，比如数学运算。为此 ES5 规范在 9.3 节定义了
抽象操作 ToNumber 。

其中 true 转换为 1 ， false 转换为 0 。 undefined 转换为 NaN ， null 转换为 0 。

对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。

为了将值转换为相应的基本类型值，抽象操作toPrimitive会首先检查该值是否有valueOf(...)方法。如果有并且返回基本类型值，就用该值进行强制转换，如果没有就是用toString(...)的返回值来进行强制的类型转换。

如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。

从 ES5 开始，使用 Object.create(null) 创建的对象 [[Prototype]] 属性为 null ，并且没
有 valueOf() 和 toString() 方法，因此无法进行强制类型转换。
~~~js
var a = {
  valueOf: function(){
  return "42";
  }
};
var b = {
  toString: function(){
  return "42";
  }
};
var c = [4,2];
  c.toString = function(){
  return this.join( "" ); // "42"
};
Number( a ); // 42
Number( b ); // 42
Number( c ); // 42
Number( "" ); // 0
Number( [] ); // 0
Number( [ "abc" ] ); // NaN
~~~