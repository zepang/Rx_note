# Boosting Node.js and MongoDB with Mongoose

# DB connection in a standalone Mongoose script

~~~js
const mongoose = require('mongoose)

mongoose.connect('mongodb://localhost:27017/test', {useMongoClient: true})
mongoose.Promise = global.Promise
~~~

# Mongoose shcema

These are the Mongoose data types:

* String
* Number
* Boolean
* Buffer
* Date
* Array
* Schema.Types.ObjectId
* Schema.Types.Mixed

It's possible to create and use custom types that already have the rules for the ubiquitous email and URL types, e.g., there's a module [mongoose-types(http://github.com/bnoguchi/mongoose-types)](http://github.com/bnoguchi/mongoose-types)

Mongoose schemas are pluggable, which means, by creating a plugin,certain functionally can be extended across all schemas of the application.

# Hooks for Keeping code organized

```js
bookSchema.pre('save', (next) => {
  // Upload pdf
  return next()
})
```

# custom static and instance methods

instance methods
```js
bookSchema.method({
  buy: function (quantity, customer, callback) {
    const bookTopPurchase = this
    return callback(results)
  }
})
```
static methods
```js
bookSchema.static({
  getZeroInventoryReport: function (callback) {
    return callback(books)
  }
})
```

Hooks and methods must be added to the schemas before compiling them to models --- in other words, before calling the `mongoose.model()` method.

# Mongoose Models

To compile a schema into a module

~~~js
const Book = mongoose.model('Book', bookSchema)
~~~

The first paramerter is just a string, which we can use latter to pull an instance of this model.Usually, this string is the same as the object literal for the model.It's usually capitalized, e.g.,`Book`.By default, Mongoose will use the model name to tie it to a collection name by pluralizing it.For example, the `Book` model will use books collection.

Nodeks are used to create documents.Document is the instance of the Model.

```js
const practicalNodeBook = new Book({name: 'Practical Node.js'})
```

# Relationships and Joins with population

Althrough, Node developers cannot query MongoDB on complex relationships, they can do so in the application layer with the help of Mongoose.

Let's say we have `posts` and `users` documents.User can write posts.There are two approches to implement this.We can use one collection.The `user` collection can have `posts` array field.This will require a single query, but this structure is limited in many ways because posts cannot be indexed or accessed separately from users.

Or we can use two collections.In this case, the structure is more flexible but requires at least two queries if we want to fetch a user and  his posts.

Don't fret.Mongoose is here to help.We can reference posts in the users schema and then populate the posts.In order to use `populate()`, we must define `ref` and the name of the model such as in the posts field of `userSchema`:
```js
const mongoose = require('mongoose')
const Shcema = mongoose.Schema

const userSchema = Schema({
  _id: Number,
  name: String,
  posts: [{
    type: Schema.Types.ObjectId,
    ref: 'Post'
  }]
})

const postSchema = Schema({
  _creator: { type: Number, ref: 'User' },
  title: String,
  text: String
})

// create two model and pull posts data with a single query.
const Post = mongoose.model('Post', postSchema)
const User = mongoose.model('User', userSchema)

User.findOne({ name: /azat/i })
  .populate('posts')
  .exec((err, user) => {
    if (err) return handleError(err)
    console.log('The user has % post(s)', user.posts.length)
  })
```
More usages:
```js
.populate({
  path: 'posts',
  // return only certain fields
  select: '_id, title, text',
  // filter the populated result
  match: { text: /node\.js/i },
  options: {
    limit: 10,
    sort: 'title'
  }
})
```

