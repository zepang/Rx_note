# Getting Node.js Apps Production Ready

Getting Node.js apps to a production-ready statu is probably the most unexplored and skipped topic in the Node.js literature.The reason could be the lack of expertise in production deployments or the vast number of options and edge cases.However, getting apps to the production level is one of themost important topics in this entire book in my humble opinion.

Yesm the apps differ in structures, the frameworks they use, and the goals they try to achieve;however, there are a few commonalities worth knowing about -- for example, environmental variables, multithreading,logging, and error handling.So, in this charpter, we cover the following topics:

* Environment varibles
* Express.js in production
* Socket.IO in production
* Error handling
* Node.js domains for error handling
* Multithreading with Cluster
* Multithreading with Cluster2
* Event logging and monitoring
* Building tasks with Grunt
* Locking dependencies
* Git for version control and deployments
* Running tests in Cloud with TravisCI

# Environment Variables
Sensitive information such as API keys, passwords, and database URIs are best stored in environment variables, not in the source code iteself.Node.js makes it fairly easy to access these variables:

```js
console.log(process.env.NODE_ENV,
process.env.API_KEY,
process.env.DB_PASSWORD)
```

Then, before the application is startedm, set these variables:

```
NODE_ENV=test API_KEY=XYZ DB_PASSWORD=ABC node envvar.js
```
Typically, the environment variables setting is a part of the deployment or operations setup.In the next cahpter, we deal with puttin these variables on the server.

# Express.js in Production

In Express.js, use if/else statements to check for `NODE_ENV` values to use different levels of server logs.For development, we want more information, but in production, stack and exceptions might reveal a vulneability, so we hide them:
```js
const errorHandler = require('errorhandler')
if (process.env.NODE_ENV === 'development') {
  app.use(errorHandler({
    dumpExceptions: true,
    showStack: true
  }))
} else {
  app.use(errorHandler())
}
```
let's talk about sessions now.When using in-memory session store (the default choice),the data can't be shared across different processes/servers (which we want in production mode).Conveniently, Express.js and Connect nofify us about this as we see in this source code with the message:
```
Warning: connect.session() MemoryStore is not
designed for a production environment, as it will leak
memory, and will not scale past a single process.
```
What we need here is single source of the truth---one location where all the session data is sotred an can be acessed by mutiple Node servers.This problem is solved easily by using a shared Redis instance as a session store.For example, for Express.js, execute the following:
```js
const session = require('express-session')
const RedisStore = require('connect-redis')(session)

app.use(session({
  sotre: new RedisStore(options),
  secret: process.env.SESSION_SECRET
}))
```
There is a more advanced example with session options that inclueds a special key and cookie domain:
```js
const SessionStore = require('connect-redis')
const session = require('express-session')

app.use(session({
  key: process.env.SESSION_KEY,
  secret: process.env.SESSION_SECRET,
  store: new SessionStore({
    cookie: { domain: '.webapplog.com' },
    db: 1,
    host: 'webapplog.com'
  })
}))
```
Options for `connect-redis` are client, host, port, ttl, db, pass, prefix, and url.For more information, please refer to the official `connect-redis` [documentation(https://github.com/visionmedia/connect-redis)](https://github.com/visionmedia/connect-redis)

# Error Handling

As a rule of thumb, when readying your code for production, make sure to listen to all error event from `http.server` and `https.Server`, i.e., always have error event listeners foing something like this:

```js
server.on('error', (err) => {
  console.log(err)
})
```

Then have catchall envent listener(`uncaughtExceptions`) for unforeseen case.This event is the last step before the app will crash, terminate the process, and burn your computer to ashes.Do not try to resume a nirmal operation when you have this event.Log, save work(if you have anything left), and exit like this:

```js
process.on('uncaughtException', (err) => {
  console.error('uncaughtException: ', err.message)
  console.error(err.stack)
  process.exit(1)
})

// Alternatively, you can use the `addListener` method
process.addListener('uncaughtException', (err) => {
  console.error('uncaughtException: ', err.message)
  console.error(err.stack)
  process.exit(1)
})
```